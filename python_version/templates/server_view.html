{% extends 'base.html' %}
{% load i18n %}
{% block title %}{{ server.name }} - Rashigo{% endblock %}
{% block extra_css %}
{{ block.super }}
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
    
    body {
        font-family: 'Inter', sans-serif !important;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 25%, #334155 50%, #1e293b 75%, #0f172a 100%) !important;
        background-size: 400% 400%;
        animation: gradientShift 20s ease infinite;
        min-height: 100vh;
    }
    
    @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    
    .server-container {
        display: grid;
        grid-template-columns: 300px 1fr 350px;
        gap: 2rem;
        max-width: 100%;
        width: 100%;
        margin: 0;
        padding: 2rem;
        min-height: calc(100vh - 80px);
        box-sizing: border-box;
    }
    
    .server-sidebar {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        height: fit-content;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        position: sticky;
        top: 1.5rem;
    }
    
    .server-header {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 2.5rem;
        margin-bottom: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        display: flex;
        align-items: center;
        gap: 2rem;
    }
    
    .server-icon-large {
        width: 100px;
        height: 100px;
        border-radius: 25px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3rem;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        flex-shrink: 0;
    }
    
    .server-info {
        flex: 1;
    }
    
    .server-info h2 {
        color: #f1f5f9;
        font-weight: 700;
        margin: 0 0 0.75rem 0;
        font-size: 2rem;
    }
    
    .server-info p {
        color: #94a3b8;
        margin: 0 0 1rem 0;
        font-size: 1.1rem;
        line-height: 1.6;
    }
    
    .channel-section {
        margin-bottom: 1.5rem;
    }
    
    .channel-section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }
    
    .channel-section-title {
        color: #94a3b8;
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .channel-count {
        color: #667eea;
        font-size: 0.7rem;
        font-weight: 600;
    }
    
    .add-channel-btn {
        background: rgba(102, 126, 234, 0.2);
        border: 1px solid rgba(102, 126, 234, 0.3);
        color: #667eea;
        padding: 0.4rem 0.8rem;
        border-radius: 8px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .add-channel-btn:hover {
        background: rgba(102, 126, 234, 0.3);
        color: #f1f5f9;
        transform: scale(1.05);
    }
    
    .add-channel-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .channel-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    
    .channel-item {
        padding: 0.75rem 1rem;
        border-radius: 10px;
        margin-bottom: 0.5rem;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .channel-item:hover {
        background: rgba(102, 126, 234, 0.15);
        transform: translateX(5px);
    }
    
    .channel-item.active {
        background: rgba(102, 126, 234, 0.3);
        border-left: 3px solid #667eea;
    }
    
    .channel-item a {
        color: #cbd5e1;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-weight: 500;
        font-size: 1rem;
    }
    
    .channel-item a:hover {
        color: #f1f5f9;
    }
    
    .channel-item.active {
        background: rgba(102, 126, 234, 0.3);
    }
    
    .channel-item.active a {
        color: #f1f5f9;
    }
    
    .members-sidebar {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        height: fit-content;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        position: sticky;
        top: 1.5rem;
    }
    
    .members-section-title {
        color: #94a3b8;
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .member-item {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem;
        border-radius: 10px;
        margin-bottom: 0.5rem;
        transition: all 0.2s ease;
    }
    
    .member-item:hover {
        background: rgba(102, 126, 234, 0.1);
    }
    
    .member-avatar {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 700;
        font-size: 1.1rem;
        flex-shrink: 0;
    }
    
    .member-info {
        flex: 1;
        min-width: 0;
    }
    
    .member-name {
        color: #f1f5f9;
        font-weight: 600;
        font-size: 1rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .member-status {
        font-size: 0.8rem;
        color: #94a3b8;
    }
    
    .online-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #10b981;
        display: inline-block;
        margin-right: 0.5rem;
        box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
    }
    
    .main-content {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 3rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        min-height: 700px;
        display: flex;
        flex-direction: column;
    }
    
    .welcome-message {
        text-align: center;
        padding: 4rem 2rem;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }
    
    .welcome-icon {
        font-size: 5rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 1.5rem;
    }
    
    .welcome-title {
        color: #f1f5f9;
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.75rem;
    }
    
    .welcome-text {
        color: #94a3b8;
        font-size: 1.1rem;
        max-width: 500px;
    }
    
    .role-badge {
        display: inline-block;
        padding: 0.35rem 0.75rem;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-left: 0.5rem;
        background: rgba(102, 126, 234, 0.2);
        color: #f8fafc;
        border: 1px solid rgba(102, 126, 234, 0.35);
    }
    
    /* Channel Creation Modal */
    .modal-content {
        background: rgba(30, 41, 59, 0.95);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(148, 163, 184, 0.2);
        color: #f1f5f9;
    }
    
    .modal-header {
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }
    
    .modal-footer {
        border-top: 1px solid rgba(148, 163, 184, 0.2);
    }
    
    /* Mobile Design */
    @media (max-width: 1200px) {
        .server-container {
            grid-template-columns: 240px 1fr 280px;
            gap: 1rem;
        }
    }
    
    @media (max-width: 992px) {
        .server-container {
            grid-template-columns: 220px 1fr;
        }
        
        .members-sidebar {
            display: none;
        }
    }
    
    @media (max-width: 768px) {
        .server-container {
            grid-template-columns: 1fr;
            padding: 1rem;
            gap: 1rem;
        }
        
        .server-sidebar {
            position: static;
            max-height: none;
            order: 2;
        }
        
        .main-content {
            order: 1;
            padding: 2rem 1.5rem;
            min-height: 500px;
        }
        
        .server-header {
            flex-direction: column;
            text-align: center;
            padding: 2rem 1.5rem;
        }
        
        .server-icon-large {
            width: 80px;
            height: 80px;
            font-size: 2.5rem;
        }
        
        .server-info h2 {
            font-size: 1.5rem;
        }
        
        .welcome-title {
            font-size: 1.5rem;
        }
        
        .welcome-icon {
            font-size: 3.5rem;
        }
        
        .members-sidebar {
            display: block;
            position: static;
            max-height: none;
            order: 3;
        }
        
        /* Mobile menu for channels */
        .mobile-channels-toggle {
            display: block;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            color: #667eea;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
        }
        
        .server-sidebar.hidden {
            display: none;
        }
    }
    
    @media (min-width: 769px) {
        .mobile-channels-toggle {
            display: none;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="server-container">
    <!-- Mobile Channels Toggle -->
    <button class="mobile-channels-toggle" onclick="document.querySelector('.server-sidebar').classList.toggle('hidden')">
        <i class="fas fa-bars"></i> {% trans "Toggle Channels" %}
    </button>
    
    <!-- Server Sidebar -->
    <div class="server-sidebar">
        <!-- Text Channels -->
        <div class="channel-section">
            <div class="channel-section-header">
                <div class="channel-section-title">
                    <i class="fas fa-hashtag"></i> {% trans "TEXT CHANNELS" %}
                    <span class="channel-count">({{ text_channels.count }})</span>
                </div>
                {% if is_owner %}
                {% with total_channels=text_channels.count|add:voice_channels.count %}
                <button class="add-channel-btn" 
                        data-bs-toggle="modal" 
                        data-bs-target="#createTextChannelModal"
                        {% if total_channels >= 100 %}disabled title="{% trans 'Maximum 100 channels reached' %}"{% endif %}>
                    <i class="fas fa-plus"></i>
                </button>
                {% endwith %}
                {% endif %}
            </div>
            <ul class="channel-list">
                {% for channel in text_channels %}
                <li class="channel-item">
                    <a href="#" class="channel-link" data-channel-type="text" data-channel-slug="{{ channel.slug }}" data-channel-name="{{ channel.name }}">
                        <i class="fas fa-hashtag"></i>
                        {{ channel.name }}
                    </a>
                </li>
                {% empty %}
                <li class="channel-item">
                    <span style="color: #64748b; font-size: 0.9rem;">{% trans "No text channels" %}</span>
                </li>
                {% endfor %}
            </ul>
        </div>
        
        <!-- Voice Channels -->
        <div class="channel-section">
            <div class="channel-section-header">
                <div class="channel-section-title">
                    <i class="fas fa-volume-up"></i> {% trans "VOICE CHANNELS" %}
                    <span class="channel-count">({{ voice_channels.count }})</span>
                </div>
                {% if is_owner %}
                {% with total_channels=text_channels.count|add:voice_channels.count %}
                <button class="add-channel-btn" 
                        data-bs-toggle="modal" 
                        data-bs-target="#createVoiceChannelModal"
                        {% if total_channels >= 100 %}disabled title="{% trans 'Maximum 100 channels reached' %}"{% endif %}>
                    <i class="fas fa-plus"></i>
                </button>
                {% endwith %}
                {% endif %}
            </div>
            <ul class="channel-list">
                {% for channel in voice_channels %}
                <li class="channel-item">
                    <a href="#" class="channel-link" data-channel-type="voice" data-channel-slug="{{ channel.slug }}" data-channel-name="{{ channel.name }}">
                        <i class="fas fa-volume-up"></i>
                        {{ channel.name }}
                    </a>
                </li>
                {% empty %}
                <li class="channel-item">
                    <span style="color: #64748b; font-size: 0.9rem;">{% trans "No voice channels" %}</span>
                </li>
                {% endfor %}
            </ul>
        </div>
        
        <!-- Channel Count Display -->
        {% if is_owner %}
        <div style="padding: 1rem; background: rgba(102, 126, 234, 0.1); border-radius: 10px; margin-top: 1rem; text-align: center;">
            <div style="color: #667eea; font-size: 0.85rem; font-weight: 600;">
                {% with total_channels=text_channels.count|add:voice_channels.count %}
                {% trans "Channels" %}: {{ total_channels }}/100
                {% endwith %}
            </div>
        </div>
        {% endif %}
    </div>
    
    <!-- Main Content -->
    <div class="main-content">
        <div class="server-header">
            <div class="server-icon-large">
                {{ server.icon|default:"ðŸŽ®" }}
            </div>
            <div class="server-info">
                <h2>
                    {{ server.name }}
                    {% if is_owner %}
                    <span class="badge bg-warning text-dark ms-2">
                        <i class="fas fa-crown"></i> {% trans "Owner" %}
                    </span>
                    {% endif %}
                </h2>
                <p>{{ server.description|default:"No description" }}</p>
                {% if user_roles %}
                <div>
                    {% for role in user_roles %}
                    <span class="role-badge">
                        {{ role.name }}
                    </span>
                    {% endfor %}
                </div>
                {% endif %}
            </div>
        </div>
        
        <!-- Welcome Message (shown when no channel selected) -->
        <div class="welcome-message" id="welcome-message">
            <div class="welcome-icon">
                <i class="fas fa-comments"></i>
            </div>
            <h3 class="welcome-title">{% trans "Welcome to" %} {{ server.name }}!</h3>
            <p class="welcome-text">
                {% trans "Select a channel from the sidebar to start chatting." %}
            </p>
        </div>
        
        <!-- Chat Area (hidden by default, shown when text channel selected) -->
        <div id="chat-area" class="hidden" style="display: none; flex-direction: column; height: calc(100vh - 200px);">
            <!-- Chat Header -->
            <div style="padding: 1rem; border-bottom: 1px solid rgba(148, 163, 184, 0.2); display: flex; align-items: center; gap: 1rem;">
                <i class="fas fa-hashtag" style="color: #94a3b8;"></i>
                <h4 style="margin: 0; color: #f1f5f9; font-weight: 600;" id="chat-channel-name">{% trans "Channel" %}</h4>
            </div>
            
            <!-- Messages Container -->
            <div id="discord-messages" style="flex: 1; overflow-y: auto; padding: 1.5rem; background: rgba(15, 23, 42, 0.3);">
                <!-- Messages will be loaded here -->
            </div>
            
            <!-- Chat Input -->
            <div style="padding: 1rem; border-top: 1px solid rgba(148, 163, 184, 0.2);">
                <div style="display: flex; align-items: center; gap: 0.75rem; background: rgba(30, 41, 59, 0.8); padding: 0.75rem; border-radius: 10px;">
                    <button class="btn btn-sm" style="background: transparent; border: none; color: #94a3b8;">
                        <i class="fas fa-plus-circle"></i>
                    </button>
                    <input type="text" id="discord-chat-input" 
                           style="flex: 1; background: transparent; border: none; outline: none; color: #f1f5f9; padding: 0.5rem;"
                           placeholder="{% trans 'Type a message...' %}" autocomplete="off">
                    <button onclick="sendChatMessage()" class="btn btn-sm" style="background: transparent; border: none; color: #94a3b8;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Voice Area (hidden by default, shown when voice channel selected) -->
        <div id="voice-stage" class="hidden" style="display: none; flex-direction: column; height: calc(100vh - 200px); background: #000; border-radius: 15px; position: relative; overflow: hidden;">
            <!-- Voice Header -->
            <div style="padding: 1rem; border-bottom: 1px solid rgba(148, 163, 184, 0.2); display: flex; align-items: center; justify-content: space-between; background: rgba(15, 23, 42, 0.5);">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <i class="fas fa-volume-up" style="color: #94a3b8;"></i>
                    <h4 style="margin: 0; color: #f1f5f9; font-weight: 600;" id="voice-channel-name">{% trans "Voice Channel" %}</h4>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="btn btn-sm" style="background: rgba(30, 41, 59, 0.8); border: none; color: #f1f5f9;">
                        <i class="fas fa-th-large"></i> {% trans "Grid" %}
                    </button>
                </div>
            </div>
            
            <!-- Video Grid -->
            <div id="video-grid" style="flex: 1; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; padding: 1.5rem; overflow-y: auto;">
                <!-- Participants will be added here -->
            </div>
            
            <!-- Screen Share Container -->
            <div id="screen-share-container" class="hidden" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #000; z-index: 10; border: 2px solid #667eea;">
                <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.9);">
                    <div style="text-align: center; color: #667eea;">
                        <i class="fas fa-desktop" style="font-size: 4rem; margin-bottom: 1rem; animation: pulse 2s infinite;"></i>
                        <h3 style="color: #f1f5f9; font-weight: 700;">{% trans "Screen Sharing Active" %}</h3>
                        <p style="color: #94a3b8;">{% trans "Live Stream - 1080p 60fps" %}</p>
                    </div>
                </div>
            </div>
            
            <!-- Voice Controls -->
            <div style="position: absolute; bottom: 1.5rem; left: 50%; transform: translateX(-50%); background: rgba(30, 41, 59, 0.95); padding: 1rem 2rem; border-radius: 50px; display: flex; gap: 1rem; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); z-index: 20;">
                <button id="mic-btn" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: rgba(100, 116, 139, 0.6); border: none; color: #f1f5f9;">
                    <i class="fas fa-microphone"></i>
                </button>
                <button id="video-btn" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: rgba(100, 116, 139, 0.6); border: none; color: #f1f5f9;">
                    <i class="fas fa-video"></i>
                </button>
                <button onclick="toggleScreenShare()" id="screen-share-btn" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: rgba(100, 116, 139, 0.6); border: none; color: #f1f5f9;">
                    <i class="fas fa-desktop"></i>
                </button>
                <button onclick="leaveVoiceChannel()" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: #ef4444; border: none; color: #f1f5f9;">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Members Sidebar -->
    <div class="members-sidebar">
        <div class="members-section-title">
            <span>{% trans "MEMBERS" %} â€” {{ members.count }}</span>
        </div>
        <div>
            {% for member in members %}
            <div class="member-item">
                <div class="member-avatar">
                    {{ member.get_display_name|first|upper }}
                </div>
                <div class="member-info">
                    <div class="member-name">
                        {{ member.get_display_name }}
                        {% if member.user == server.owner %}
                        <i class="fas fa-crown text-warning ms-1" style="font-size: 0.7rem;"></i>
                        {% endif %}
                    </div>
                    <div class="member-status">
                        {% if member.is_online %}
                        <span class="online-indicator"></span>{% trans "Online" %}
                        {% else %}
                        <span style="color: #64748b;">{% trans "Offline" %}</span>
                        {% endif %}
                    </div>
                </div>
            </div>
            {% empty %}
            <p style="color: #64748b; font-size: 0.9rem; text-align: center; padding: 1rem;">{% trans "No members" %}</p>
            {% endfor %}
        </div>
    </div>
</div>

<!-- Create Text Channel Modal -->
{% if is_owner %}
<div class="modal fade" id="createTextChannelModal" tabindex="-1" aria-labelledby="createTextChannelModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createTextChannelModalLabel">
                    <i class="fas fa-hashtag me-2"></i>{% trans "Create Text Channel" %}
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form method="post" action="{% url 'create_text_channel' server_slug=server.slug %}">
                {% csrf_token %}
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="textChannelName" class="form-label">{% trans "Channel Name" %}</label>
                        <input type="text" class="form-control" id="textChannelName" name="name" 
                               placeholder="{% trans 'general' %}" required maxlength="100">
                    </div>
                    <div class="mb-3">
                        <label for="textChannelDescription" class="form-label">{% trans "Description" %} ({% trans "Optional" %})</label>
                        <textarea class="form-control" id="textChannelDescription" name="description" 
                                  rows="3" placeholder="{% trans 'Channel description...' %}"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="textChannelPosition" class="form-label">{% trans "Position" %}</label>
                        <input type="number" class="form-control" id="textChannelPosition" name="position" 
                               value="0" min="0">
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="textChannelPrivate" name="is_private">
                        <label class="form-check-label" for="textChannelPrivate">
                            {% trans "Private Channel" %}
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{% trans "Cancel" %}</button>
                    <button type="submit" class="btn btn-primary">
                        <i class="fas fa-plus me-2"></i>{% trans "Create Channel" %}
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Create Voice Channel Modal -->
<div class="modal fade" id="createVoiceChannelModal" tabindex="-1" aria-labelledby="createVoiceChannelModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createVoiceChannelModalLabel">
                    <i class="fas fa-volume-up me-2"></i>{% trans "Create Voice Channel" %}
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form method="post" action="{% url 'create_voice_channel' server_slug=server.slug %}">
                {% csrf_token %}
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="voiceChannelName" class="form-label">{% trans "Channel Name" %}</label>
                        <input type="text" class="form-control" id="voiceChannelName" name="name" 
                               placeholder="{% trans 'General' %}" required maxlength="100">
                    </div>
                    <div class="mb-3">
                        <label for="voiceChannelDescription" class="form-label">{% trans "Description" %} ({% trans "Optional" %})</label>
                        <textarea class="form-control" id="voiceChannelDescription" name="description" 
                                  rows="3" placeholder="{% trans 'Channel description...' %}"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="voiceChannelPosition" class="form-label">{% trans "Position" %}</label>
                        <input type="number" class="form-control" id="voiceChannelPosition" name="position" 
                               value="0" min="0">
                    </div>
                    <div class="mb-3">
                        <label for="voiceChannelUserLimit" class="form-label">{% trans "User Limit" %} (0 = {% trans "Unlimited" %})</label>
                        <input type="number" class="form-control" id="voiceChannelUserLimit" name="user_limit" 
                               value="0" min="0" max="99">
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="voiceChannelPrivate" name="is_private">
                        <label class="form-check-label" for="voiceChannelPrivate">
                            {% trans "Private Channel" %}
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{% trans "Cancel" %}</button>
                    <button type="submit" class="btn btn-primary">
                        <i class="fas fa-plus me-2"></i>{% trans "Create Channel" %}
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
<script>
    // Get COTURN settings from backend (one server handles all voice channels)
    const coturnConfig = JSON.parse('{{ coturn_config_json|escapejs }}');
    
    // COTURN Configuration for WebRTC
    // One COTURN server can handle multiple voice channels - it's just for NAT traversal
    const iceServers = [
        { urls: coturnConfig.stun_url || 'stun:31.58.244.167:3478' },
        {
            urls: coturnConfig.turn_url || 'turn:31.58.244.167:3478',
            username: coturnConfig.turn_username || 'adem',
            credential: coturnConfig.turn_credential || 'fb1907'
        },
        { urls: coturnConfig.stun_url_2 || 'stun:stun.l.google.com:19302' }
    ];
    
    console.log('COTURN Configuration (backend):', iceServers);
    
    let currentChannelSlug = null;
    let currentChannelType = null; // 'text' or 'voice'
    let chatSocket = null;
    let localStream = null;
    let peerConnections = {};
    let isMuted = false;
    let isVideoEnabled = true;
    
    const messageList = document.getElementById('discord-messages');
    const chatInput = document.getElementById('discord-chat-input');
    const welcomeMessage = document.getElementById('welcome-message');
    const chatArea = document.getElementById('chat-area');
    const voiceStage = document.getElementById('voice-stage');
    
    // Handle channel clicks
    document.querySelectorAll('.channel-link').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const channelType = this.getAttribute('data-channel-type');
            const channelSlug = this.getAttribute('data-channel-slug');
            const channelName = this.getAttribute('data-channel-name');
            
            // Update active state
            document.querySelectorAll('.channel-link').forEach(l => l.parentElement.classList.remove('active'));
            this.parentElement.classList.add('active');
            
            if (channelType === 'text') {
                openTextChannel(channelSlug, channelName);
            } else if (channelType === 'voice') {
                openVoiceChannel(channelSlug, channelName);
            }
        });
    });
    
    function openTextChannel(slug, name) {
        // Clean up voice channel if switching from voice
        if (currentChannelType === 'voice') {
            cleanupVoiceChannel();
        }
        
        currentChannelSlug = slug;
        currentChannelType = 'text';
        
        // Close previous WebSocket connection
        if (chatSocket) {
            chatSocket.close();
            chatSocket = null;
        }
        
        // Update UI
        welcomeMessage.style.display = 'none';
        voiceStage.style.display = 'none';
        chatArea.style.display = 'flex';
        document.getElementById('chat-channel-name').textContent = name;
        
        // Clear messages before loading new ones
        if (messageList) {
            messageList.innerHTML = '';
        }
        
        // Connect WebSocket and load history
        connectWebSocket();
        loadChatHistory();
    }
    
    function openVoiceChannel(slug, name) {
        // Clean up previous voice channel first
        cleanupVoiceChannel();
        
        currentChannelSlug = slug;
        currentChannelType = 'voice';
        
        // Update UI
        welcomeMessage.style.display = 'none';
        chatArea.style.display = 'none';
        voiceStage.style.display = 'flex';
        document.getElementById('voice-channel-name').textContent = name;
        
        // Clear video grid
        const videoGrid = document.getElementById('video-grid');
        videoGrid.innerHTML = '';
        
        // Initialize voice
        initializeVoice();
    }
    
    function cleanupVoiceChannel() {
        // Stop local stream
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        
        // Close all peer connections
        Object.values(peerConnections).forEach(pc => {
            pc.close();
        });
        peerConnections = {};
        
        // Close WebSocket if open
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.close();
        }
        
        // Clear video grid
        const videoGrid = document.getElementById('video-grid');
        if (videoGrid) {
            videoGrid.innerHTML = '';
        }
        
        // Reset states
        isMuted = false;
        isVideoEnabled = true;
    }
    
    // WebSocket for chat
    function connectWebSocket() {
        if (!currentChannelSlug || currentChannelType !== 'text') return;
        
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // Add channel_type parameter to disambiguate between TextChannel and VoiceChannel with same slug
        const wsUrl = `${wsProtocol}//${window.location.host}/ws/voice/?channel_slug=${currentChannelSlug}&channel_type=text`;
        
        if (chatSocket) {
            chatSocket.close();
        }
        
        chatSocket = new WebSocket(wsUrl);
        
        chatSocket.onopen = function() {
            console.log("WebSocket Connected");
        };
        
        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            // Only handle chat messages for text channels
            // Don't show system_notification for text channels (prevents "joined room" spam)
            if (data.type === 'chat_message') {
                addMessageToList(data.username, data.message, data.timestamp);
            }
            // Ignore system_notification for text channels
        };
        
        chatSocket.onclose = function() {
            console.log("WebSocket Disconnected");
            if (currentChannelType === 'text') {
                setTimeout(connectWebSocket, 3000);
            }
        };
        
        chatSocket.onerror = function(error) {
            console.error("WebSocket Error:", error);
        };
    }
    
    function addMessageToList(username, content, timestamp) {
        const div = document.createElement('div');
        div.style.cssText = 'display: flex; gap: 1rem; padding: 0.75rem; margin-bottom: 0.5rem; border-radius: 8px; transition: background 0.2s;';
        div.className = 'message-item';
        
        const date = timestamp ? new Date(timestamp) : new Date();
        const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        
        div.innerHTML = `
            <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=random" 
                 style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
            <div style="flex: 1;">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                    <span style="color: #f1f5f9; font-weight: 600;">${escapeHtml(username)}</span>
                    <span style="color: #64748b; font-size: 0.85rem;">${timeStr}</span>
                </div>
                <p style="color: #cbd5e1; margin: 0;">${escapeHtml(content)}</p>
            </div>
        `;
        
        messageList.appendChild(div);
        messageList.scrollTop = messageList.scrollHeight;
    }
    
    function addSystemMessage(message) {
        const div = document.createElement('div');
        div.style.cssText = 'text-align: center; color: #64748b; padding: 0.5rem; font-size: 0.9rem;';
        div.textContent = message;
        messageList.appendChild(div);
        messageList.scrollTop = messageList.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function sendChatMessage() {
        const message = chatInput.value.trim();
        if (!message || !chatSocket || chatSocket.readyState !== WebSocket.OPEN) return;
        
        chatSocket.send(JSON.stringify({
            signal_type: 'chat_message',
            data: message
        }));
        
        chatInput.value = '';
    }
    
    if (chatInput) {
        chatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatMessage();
            }
        });
    }
    
    async function loadChatHistory() {
        if (!currentChannelSlug) return;
        
        try {
            const response = await fetch(`/api/chat/${currentChannelSlug}/messages/`);
            const data = await response.json();
            
            messageList.innerHTML = '';
            data.messages.forEach(msg => {
                addMessageToList(msg.author, msg.content, msg.timestamp);
            });
        } catch (error) {
            console.error("Error loading chat history:", error);
        }
    }
    
    // Voice functionality
    async function initializeVoice() {
        try {
            console.log("Initializing voice channel...");
            
            // Request media access first
            localStream = await navigator.mediaDevices.getUserMedia({ 
                audio: true, 
                video: isVideoEnabled  // Use the current video state
            });
            
            console.log("Media stream obtained:", localStream.getTracks().length, "tracks");
            
            // Connect to WebSocket FIRST (before adding user to grid)
            // This ensures we're in the channel group when we appear
            connectVoiceWebSocket();
            
            // Add local user to video grid after connecting
            // Wait a bit for WebSocket to connect
            setTimeout(() => {
                // Add local user to video grid with video element if camera is on
                addParticipantToGrid('{{ user.username }}', localStream, true);
                
                // If video is enabled, show it
                if (isVideoEnabled && localStream.getVideoTracks().length > 0) {
                    const participantDiv = document.getElementById('participant-{{ user.username }}');
                    if (participantDiv) {
                        const avatar = participantDiv.querySelector('.participant-avatar');
                        if (avatar) {
                            // Replace avatar with video element
                            const videoElement = document.createElement('video');
                            videoElement.srcObject = localStream;
                            videoElement.autoplay = true;
                            videoElement.muted = true; // Mute own video
                            videoElement.style.cssText = 'width: 100%; height: 100%; max-width: 300px; max-height: 300px; object-fit: cover; border-radius: 15px; margin-bottom: 1rem;';
                            avatar.replaceWith(videoElement);
                        }
                    }
                }
                
                console.log('Voice channel fully initialized');
            }, 300);
            
        } catch (error) {
            console.error("Error accessing media devices:", error);
            alert("{% trans 'Could not access microphone/camera. Please check permissions.' %}");
            // Still try to connect WebSocket even if media fails
            connectVoiceWebSocket();
        }
    }
    
    function connectVoiceWebSocket() {
        if (!currentChannelSlug || currentChannelType !== 'voice') {
            console.warn("Cannot connect: missing channel slug or not voice channel");
            return;
        }
        
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // Add channel_type parameter to disambiguate between TextChannel and VoiceChannel with same slug
        const wsUrl = `${wsProtocol}//${window.location.host}/ws/voice/?channel_slug=${currentChannelSlug}&channel_type=voice`;
        
        console.log("Connecting to voice WebSocket:", wsUrl);
        
        // Close existing socket if open (to create fresh connection for voice)
        if (chatSocket) {
            chatSocket.onerror = null;
            chatSocket.onclose = null;
            chatSocket.close();
            chatSocket = null;
        }
        
        // Create new WebSocket connection for voice channel
        try {
            chatSocket = new WebSocket(wsUrl);
        } catch (error) {
            console.error("Failed to create WebSocket:", error);
            alert("Failed to connect to voice channel. Please refresh and try again.");
            return;
        }
        
        chatSocket.onopen = function() {
            console.log("Voice WebSocket Connected successfully");
            // Notify that connection is ready
            if (currentChannelType === 'voice') {
                console.log("Ready for voice communication");
            }
        };
        
        chatSocket.onerror = function(error) {
            console.error("Voice WebSocket Error:", error);
            // Try to reconnect after a delay
            if (currentChannelType === 'voice') {
                setTimeout(() => {
                    if (currentChannelType === 'voice' && (!chatSocket || chatSocket.readyState === WebSocket.CLOSED)) {
                        console.log("Attempting to reconnect voice WebSocket...");
                        connectVoiceWebSocket();
                    }
                }, 3000);
            }
        };
        
        chatSocket.onclose = function(event) {
            console.log("Voice WebSocket Closed", event.code, event.reason);
            // Try to reconnect if we're still in a voice channel
            if (currentChannelType === 'voice' && currentChannelSlug) {
                console.log("Attempting to reconnect voice WebSocket in 2 seconds...");
                setTimeout(() => {
                    if (currentChannelType === 'voice' && currentChannelSlug) {
                        connectVoiceWebSocket();
                    }
                }, 2000);
            }
        };
        
        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            
            // Handle member joined event (only for voice channels)
            if (data.type === 'system_notification' && data.event === 'member_joined') {
                console.log('Member joined voice channel:', data.username);
                // Add the new member to the grid if not already present and not self
                if (data.username !== '{{ user.username }}') {
                    // Check if participant already exists
                    let participantDiv = document.getElementById(`participant-${data.username}`);
                    if (!participantDiv) {
                        // Add new participant with placeholder avatar
                        participantDiv = addParticipantToGrid(data.username, null, false);
                        console.log(`Added ${data.username} to voice grid`);
                    } else {
                        console.log(`${data.username} already in grid`);
                    }
                }
            }
            
            // Handle member left event (only for voice channels)
            if (data.type === 'system_notification' && data.event === 'member_left') {
                console.log('Member left voice channel:', data.username);
                // Remove the member from the grid
                const participantDiv = document.getElementById(`participant-${data.username}`);
                if (participantDiv) {
                    participantDiv.remove();
                    console.log(`Removed ${data.username} from voice grid`);
                }
            }
            
            // Handle microphone state changes from other users
            if (data.type === 'mic_state_change' && data.data) {
                updateParticipantMicState(data.data.username, !data.data.muted);
            }
            
            // Handle camera state changes from other users
            if (data.type === 'camera_state_change' && data.data) {
                updateParticipantVideoState(data.data.username, data.data.enabled);
            }
            
            // Handle WebRTC signaling if needed (for future peer-to-peer implementation)
            if (data.type === 'webrtc_offer') {
                // handleOffer(data);
                console.log('WebRTC offer received (not implemented yet)');
            } else if (data.type === 'webrtc_answer') {
                // handleAnswer(data);
                console.log('WebRTC answer received (not implemented yet)');
            } else if (data.type === 'webrtc_ice_candidate') {
                // handleIceCandidate(data);
                console.log('WebRTC ICE candidate received (not implemented yet)');
            } else if (data.type === 'chat_message') {
                // Can receive chat messages in voice channels too
                console.log('Chat message in voice channel:', data);
            } else {
                // Log any other message types for debugging
                console.log('Received voice channel message:', data);
            }
        };
    }
    
    function addParticipantToGrid(username, stream, isLocal = false) {
        const videoGrid = document.getElementById('video-grid');
        const participantId = `participant-${username}`;
        
        // Check if participant already exists
        let participantDiv = document.getElementById(participantId);
        if (participantDiv) {
            console.log(`Participant ${username} already exists, updating...`);
            return participantDiv;
        }
        
        participantDiv = document.createElement('div');
        participantDiv.id = participantId;
        participantDiv.dataset.username = username;
        participantDiv.dataset.micMuted = 'false';
        participantDiv.dataset.videoEnabled = 'true';
        participantDiv.style.cssText = 'background: rgba(30, 41, 59, 0.8); border-radius: 15px; padding: 1.5rem; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; border: 2px solid transparent;';
        
        const avatar = document.createElement('div');
        avatar.className = 'participant-avatar';
        avatar.style.cssText = 'width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; font-size: 2.5rem; color: white; font-weight: 700; margin-bottom: 1rem;';
        avatar.textContent = username.charAt(0).toUpperCase();
        
        const nameLabel = document.createElement('div');
        nameLabel.className = 'participant-name-label';
        nameLabel.style.cssText = 'position: absolute; bottom: 1rem; left: 1rem; background: rgba(0, 0, 0, 0.6); padding: 0.5rem 1rem; border-radius: 8px; color: #f1f5f9; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;';
        nameLabel.innerHTML = `<i class="fas fa-microphone participant-mic-icon" style="color: #3ba55c;"></i> ${escapeHtml(username)}`;
        
        participantDiv.appendChild(avatar);
        participantDiv.appendChild(nameLabel);
        videoGrid.appendChild(participantDiv);
        
        return participantDiv;
    }
    
    // Update participant microphone state (visible to everyone)
    function updateParticipantMicState(username, isEnabled) {
        const participantDiv = document.querySelector(`#participant-${username}, [data-username="${username}"]`);
        if (!participantDiv) return;
        
        participantDiv.dataset.micMuted = (!isEnabled).toString();
        const micIcon = participantDiv.querySelector('.participant-mic-icon');
        
        if (micIcon) {
            if (isEnabled) {
                micIcon.className = 'fas fa-microphone participant-mic-icon';
                micIcon.style.color = '#3ba55c';
            } else {
                micIcon.className = 'fas fa-microphone-slash participant-mic-icon';
                micIcon.style.color = '#ef4444';
            }
        }
        
        // Add visual indicator
        if (!isEnabled) {
            participantDiv.style.opacity = '0.7';
        } else {
            participantDiv.style.opacity = '1';
        }
    }
    
    // Update participant camera state (visible to everyone)
    function updateParticipantVideoState(username, isEnabled) {
        const participantDiv = document.querySelector(`#participant-${username}, [data-username="${username}"]`);
        if (!participantDiv) return;
        
        participantDiv.dataset.videoEnabled = isEnabled.toString();
        const avatar = participantDiv.querySelector('.participant-avatar');
        
        if (avatar) {
            if (isEnabled) {
                avatar.style.border = '2px solid transparent';
            } else {
                avatar.style.border = '2px solid #ef4444';
                // Add camera-off overlay
                let overlay = participantDiv.querySelector('.camera-off-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.className = 'camera-off-overlay';
                    overlay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.7); padding: 0.5rem 1rem; border-radius: 8px; color: #ef4444; font-weight: 600;';
                    overlay.innerHTML = '<i class="fas fa-video-slash"></i> Camera Off';
                    participantDiv.appendChild(overlay);
                }
                overlay.style.display = 'block';
            }
        }
        
        // Remove overlay if camera is enabled
        if (isEnabled) {
            const overlay = participantDiv.querySelector('.camera-off-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }
    }
    
    function toggleScreenShare() {
        const container = document.getElementById('screen-share-container');
        const btn = document.getElementById('screen-share-btn');
        
        if (container.classList.contains('hidden')) {
            navigator.mediaDevices.getDisplayMedia({ video: true })
                .then(stream => {
                    container.classList.remove('hidden');
                    container.style.display = 'flex';
                    btn.style.background = '#3ba55c';
                    
                    stream.getVideoTracks()[0].onended = () => {
                        container.classList.add('hidden');
                        container.style.display = 'none';
                        btn.style.background = 'rgba(100, 116, 139, 0.6)';
                    };
                })
                .catch(err => {
                    console.error("Screen share error:", err);
                    alert("{% trans 'Could not start screen share. Please check permissions.' %}");
                });
        } else {
            container.classList.add('hidden');
            container.style.display = 'none';
            btn.style.background = 'rgba(100, 116, 139, 0.6)';
        }
    }
    
    function leaveVoiceChannel() {
        cleanupVoiceChannel();
        
        // Reset UI
        welcomeMessage.style.display = 'block';
        voiceStage.style.display = 'none';
        currentChannelSlug = null;
        currentChannelType = null;
        
        // Remove active state from channel
        document.querySelectorAll('.channel-item').forEach(item => {
            item.classList.remove('active');
        });
    }
    
    // Close/Disable Microphone
    function closeMicrophone() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = false; // Don't stop, just disable
            });
        }
        isMuted = true;
        
        // Update UI
        const btn = document.getElementById('mic-btn');
        if (btn) {
            btn.style.background = '#ef4444';
            const icon = btn.querySelector('i');
            if (icon) {
                icon.className = 'fas fa-microphone-slash';
            }
        }
        
        // Update local user's participant display
        updateParticipantMicState('{{ user.username }}', false);
        
        // Broadcast state change to all users in channel
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                signal_type: 'mic_state_change',
                data: {
                    username: '{{ user.username }}',
                    muted: true
                }
            }));
        }
        
        console.log('Microphone closed');
    }
    
    // Close/Disable Camera
    function closeCamera() {
        if (localStream) {
            localStream.getVideoTracks().forEach(track => {
                track.enabled = false; // Don't stop, just disable
            });
        }
        isVideoEnabled = false;
        
        // Update UI
        const btn = document.getElementById('video-btn');
        if (btn) {
            btn.style.background = '#ef4444';
            const icon = btn.querySelector('i');
            if (icon) {
                icon.className = 'fas fa-video-slash';
            }
        }
        
        // Hide video and show avatar again
        const participantDiv = document.getElementById('participant-{{ user.username }}');
        if (participantDiv) {
            const videoElement = participantDiv.querySelector('video');
            if (videoElement) {
                // Replace video with avatar
                const avatar = document.createElement('div');
                avatar.className = 'participant-avatar';
                avatar.style.cssText = 'width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; font-size: 2.5rem; color: white; font-weight: 700; margin-bottom: 1rem;';
                avatar.textContent = '{{ user.username }}'.charAt(0).toUpperCase();
                videoElement.replaceWith(avatar);
            }
        }
        
        // Update local user's participant display
        updateParticipantVideoState('{{ user.username }}', false);
        
        // Broadcast state change to all users in channel
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                signal_type: 'camera_state_change',
                data: {
                    username: '{{ user.username }}',
                    enabled: false
                }
            }));
        }
        
        console.log('Camera closed');
    }
    
    // Close/Disable Headphones (Audio Output)
    function closeHeadphones() {
        // Stop all audio tracks from local stream
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.stop();
            });
        }
        
        // Stop all remote audio streams
        Object.values(peerConnections).forEach(pc => {
            if (pc.getReceivers) {
                pc.getReceivers().forEach(receiver => {
                    if (receiver.track && receiver.track.kind === 'audio') {
                        receiver.track.stop();
                    }
                });
            }
        });
        
        // Mute all audio elements if any
        document.querySelectorAll('audio, video').forEach(element => {
            element.muted = true;
            element.pause();
        });
        
        console.log('Headphones/Audio output closed');
    }
    
    // Enable/Open Microphone
    async function openMicrophone() {
        try {
            if (!localStream) {
                // Need to create a new stream
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: isVideoEnabled 
                });
                addParticipantToGrid('{{ user.username }}', localStream, true);
            } else {
                // Get new audio track
                const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioTrack = audioStream.getAudioTracks()[0];
                
                // Replace audio track in existing stream
                localStream.addTrack(audioTrack);
                
                // Update peer connections with new track
                Object.values(peerConnections).forEach(pc => {
                    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
                    if (sender) {
                        sender.replaceTrack(audioTrack);
                    }
                });
            }
            
            isMuted = false;
            
            // Update UI
            const btn = document.getElementById('mic-btn');
            if (btn) {
                btn.style.background = 'rgba(100, 116, 139, 0.6)';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-microphone';
                }
            }
            
            // Update local user's participant display
            updateParticipantMicState('{{ user.username }}', true);
            
            // Broadcast state change to all users in channel
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    signal_type: 'mic_state_change',
                    data: {
                        username: '{{ user.username }}',
                        muted: false
                    }
                }));
            }
            
            console.log('Microphone opened');
        } catch (error) {
            console.error('Error opening microphone:', error);
            alert('{% trans "Could not open microphone. Please check permissions." %}');
        }
    }
    
    // Enable/Open Camera
    async function openCamera() {
        try {
            if (!localStream) {
                // Need to create a new stream
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: isMuted ? false : true, 
                    video: true 
                });
                addParticipantToGrid('{{ user.username }}', localStream, true);
            } else {
                // Get new video track
                const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                const videoTrack = videoStream.getVideoTracks()[0];
                
                // Remove old video tracks
                localStream.getVideoTracks().forEach(track => {
                    localStream.removeTrack(track);
                    track.stop();
                });
                
                // Add new video track to existing stream
                localStream.addTrack(videoTrack);
                
                // Update peer connections with new track
                Object.values(peerConnections).forEach(pc => {
                    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        sender.replaceTrack(videoTrack);
                    } else {
                        // If no video sender exists, add one
                        pc.addTrack(videoTrack, localStream);
                    }
                });
            }
            
            isVideoEnabled = true;
            
            // Update UI button
            const btn = document.getElementById('video-btn');
            if (btn) {
                btn.style.background = 'rgba(100, 116, 139, 0.6)';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-video';
                }
            }
            
            // Show video in participant display
            const participantDiv = document.getElementById('participant-{{ user.username }}');
            if (participantDiv && localStream.getVideoTracks().length > 0) {
                // Find avatar or video element
                let videoElement = participantDiv.querySelector('video');
                const avatar = participantDiv.querySelector('.participant-avatar');
                
                if (!videoElement && avatar) {
                    // Create video element to replace avatar
                    videoElement = document.createElement('video');
                    videoElement.autoplay = true;
                    videoElement.muted = true; // Mute own video
                    videoElement.style.cssText = 'width: 100%; height: 100%; max-width: 300px; max-height: 300px; object-fit: cover; border-radius: 15px; margin-bottom: 1rem;';
                    avatar.replaceWith(videoElement);
                }
                
                if (videoElement) {
                    videoElement.srcObject = localStream;
                }
            }
            
            // Update local user's participant display
            updateParticipantVideoState('{{ user.username }}', true);
            
            // Broadcast state change to all users in channel
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    signal_type: 'camera_state_change',
                    data: {
                        username: '{{ user.username }}',
                        enabled: true
                    }
                }));
            }
            
            console.log('Camera opened');
        } catch (error) {
            console.error('Error opening camera:', error);
            alert('{% trans "Could not open camera. Please check permissions." %}');
        }
    }
    
    // Enable/Open Headphones (Audio Output)
    function openHeadphones() {
        // Unmute all audio elements
        document.querySelectorAll('audio, video').forEach(element => {
            element.muted = false;
        });
        
        // Re-enable remote audio tracks
        Object.values(peerConnections).forEach(pc => {
            if (pc.getReceivers) {
                pc.getReceivers().forEach(receiver => {
                    if (receiver.track && receiver.track.kind === 'audio') {
                        receiver.track.enabled = true;
                    }
                });
            }
        });
        
        console.log('Headphones/Audio output opened');
    }
    
    // Use event delegation to prevent duplicate event listeners
    document.addEventListener('click', function(e) {
        // Microphone toggle
        if (e.target.closest('#mic-btn')) {
            const btn = e.target.closest('#mic-btn');
            e.preventDefault();
            
            if (isMuted) {
                // If muted, open microphone
                openMicrophone();
            } else {
                // If not muted, close microphone
                closeMicrophone();
            }
        }
        
        // Video toggle
        if (e.target.closest('#video-btn')) {
            const btn = e.target.closest('#video-btn');
            e.preventDefault();
            
            if (isVideoEnabled) {
                // If enabled, close camera
                closeCamera();
            } else {
                // If disabled, open camera
                openCamera();
            }
        }
        
        // Headphones toggle (if you add a button for it)
        if (e.target.closest('#headphone-btn')) {
            const btn = e.target.closest('#headphone-btn');
            e.preventDefault();
            
            // Toggle headphones state (you can add state tracking if needed)
            const isHeadphonesMuted = btn.dataset.muted === 'true';
            if (isHeadphonesMuted) {
                openHeadphones();
                btn.dataset.muted = 'false';
                btn.style.background = 'rgba(100, 116, 139, 0.6)';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-headphones';
                }
            } else {
                closeHeadphones();
                btn.dataset.muted = 'true';
                btn.style.background = '#ef4444';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-headphones-alt';
                }
            }
        }
    });
    
    // Expose functions globally for external use
    window.closeMicrophone = closeMicrophone;
    window.closeCamera = closeCamera;
    window.closeHeadphones = closeHeadphones;
    window.openMicrophone = openMicrophone;
    window.openCamera = openCamera;
    window.openHeadphones = openHeadphones;
</script>
{% endblock %}
