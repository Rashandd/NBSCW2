{% extends 'base.html' %}
{% load i18n %}
{% block title %}{{ server.name }} - Rashigo{% endblock %}
{% block extra_css %}
{{ block.super }}
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');
    
    body {
        font-family: 'Inter', sans-serif !important;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 25%, #334155 50%, #1e293b 75%, #0f172a 100%) !important;
        background-size: 400% 400%;
        animation: gradientShift 20s ease infinite;
        min-height: 100vh;
    }
    
    @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    
    .server-container {
        display: grid;
        grid-template-columns: 300px 1fr 350px;
        gap: 2rem;
        max-width: 100%;
        width: 100%;
        margin: 0;
        padding: 2rem;
        min-height: calc(100vh - 80px);
        box-sizing: border-box;
    }
    
    .server-sidebar {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        height: fit-content;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        position: sticky;
        top: 1.5rem;
    }
    
    .server-header {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 2.5rem;
        margin-bottom: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        display: flex;
        align-items: center;
        gap: 2rem;
    }
    
    .server-icon-large {
        width: 100px;
        height: 100px;
        border-radius: 25px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3rem;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        flex-shrink: 0;
    }
    
    .server-info {
        flex: 1;
    }
    
    .server-info h2 {
        color: #f1f5f9;
        font-weight: 700;
        margin: 0 0 0.75rem 0;
        font-size: 2rem;
    }
    
    .server-info p {
        color: #94a3b8;
        margin: 0 0 1rem 0;
        font-size: 1.1rem;
        line-height: 1.6;
    }
    
    .channel-section {
        margin-bottom: 1.5rem;
    }
    
    .channel-section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }
    
    .channel-section-title {
        color: #94a3b8;
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .channel-count {
        color: #667eea;
        font-size: 0.7rem;
        font-weight: 600;
    }
    
    .add-channel-btn {
        background: rgba(102, 126, 234, 0.2);
        border: 1px solid rgba(102, 126, 234, 0.3);
        color: #667eea;
        padding: 0.4rem 0.8rem;
        border-radius: 8px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .add-channel-btn:hover {
        background: rgba(102, 126, 234, 0.3);
        color: #f1f5f9;
        transform: scale(1.05);
    }
    
    .add-channel-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .channel-list {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    
    .channel-item {
        padding: 0.75rem 1rem;
        border-radius: 10px;
        margin-bottom: 0.5rem;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .channel-item:hover {
        background: rgba(102, 126, 234, 0.15);
        transform: translateX(5px);
    }
    
    .channel-item.active {
        background: rgba(102, 126, 234, 0.3);
        border-left: 3px solid #667eea;
    }
    
    .channel-item a {
        color: #cbd5e1;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-weight: 500;
        font-size: 1rem;
    }
    
    .channel-item a:hover {
        color: #f1f5f9;
    }
    
    .channel-item.active {
        background: rgba(102, 126, 234, 0.3);
    }
    
    .channel-item.active a {
        color: #f1f5f9;
    }
    
    .members-sidebar {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        height: fit-content;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        position: sticky;
        top: 1.5rem;
    }
    
    .members-section-title {
        color: #94a3b8;
        font-size: 0.75rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .member-item {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem;
        border-radius: 10px;
        margin-bottom: 0.5rem;
        transition: all 0.2s ease;
    }
    
    .member-item:hover {
        background: rgba(102, 126, 234, 0.1);
    }
    
    .member-avatar {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 700;
        font-size: 1.1rem;
        flex-shrink: 0;
    }
    
    .member-info {
        flex: 1;
        min-width: 0;
    }
    
    .member-name {
        color: #f1f5f9;
        font-weight: 600;
        font-size: 1rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .member-status {
        font-size: 0.8rem;
        color: #94a3b8;
    }
    
    .online-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #10b981;
        display: inline-block;
        margin-right: 0.5rem;
        box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
    }
    
    .main-content {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        padding: 3rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        min-height: 700px;
        display: flex;
        flex-direction: column;
    }
    
    .welcome-message {
        text-align: center;
        padding: 4rem 2rem;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }
    
    .welcome-icon {
        font-size: 5rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 1.5rem;
    }
    
    .welcome-title {
        color: #f1f5f9;
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.75rem;
    }
    
    .welcome-text {
        color: #94a3b8;
        font-size: 1.1rem;
        max-width: 500px;
    }
    
    .role-badge {
        display: inline-block;
        padding: 0.35rem 0.75rem;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-left: 0.5rem;
        background: rgba(102, 126, 234, 0.2);
        color: #f8fafc;
        border: 1px solid rgba(102, 126, 234, 0.35);
    }
    
    /* Channel Creation Modal */
    .modal-content {
        background: rgba(30, 41, 59, 0.95);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(148, 163, 184, 0.2);
        color: #f1f5f9;
    }
    
    .modal-header {
        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }
    
    .modal-footer {
        border-top: 1px solid rgba(148, 163, 184, 0.2);
    }
    
    /* Mobile Design */
    @media (max-width: 1200px) {
        .server-container {
            grid-template-columns: 240px 1fr 280px;
            gap: 1rem;
        }
    }
    
    @media (max-width: 992px) {
        .server-container {
            grid-template-columns: 220px 1fr;
        }
        
        .members-sidebar {
            display: none;
        }
    }
    
    @media (max-width: 768px) {
        .server-container {
            grid-template-columns: 1fr;
            padding: 1rem;
            gap: 1rem;
        }
        
        .server-sidebar {
            position: static;
            max-height: none;
            order: 2;
        }
        
        .main-content {
            order: 1;
            padding: 2rem 1.5rem;
            min-height: 500px;
        }
        
        .server-header {
            flex-direction: column;
            text-align: center;
            padding: 2rem 1.5rem;
        }
        
        .server-icon-large {
            width: 80px;
            height: 80px;
            font-size: 2.5rem;
        }
        
        .server-info h2 {
            font-size: 1.5rem;
        }
        
        .welcome-title {
            font-size: 1.5rem;
        }
        
        .welcome-icon {
            font-size: 3.5rem;
        }
        
        .members-sidebar {
            display: block;
            position: static;
            max-height: none;
            order: 3;
        }
        
        /* Mobile menu for channels */
        .mobile-channels-toggle {
            display: block;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            color: #667eea;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
            cursor: pointer;
        }
        
        .server-sidebar.hidden {
            display: none;
        }
    }
    
    @media (min-width: 769px) {
        .mobile-channels-toggle {
            display: none;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="server-container">
    <!-- Mobile Channels Toggle -->
    <button class="mobile-channels-toggle" onclick="document.querySelector('.server-sidebar').classList.toggle('hidden')">
        <i class="fas fa-bars"></i> {% trans "Toggle Channels" %}
    </button>
    
    <!-- Server Sidebar -->
    <div class="server-sidebar">
        <!-- Text Channels -->
        <div class="channel-section">
            <div class="channel-section-header">
                <div class="channel-section-title">
                    <i class="fas fa-hashtag"></i> {% trans "TEXT CHANNELS" %}
                    <span class="channel-count">({{ text_channels.count }})</span>
                </div>
                {% if is_owner %}
                {% with total_channels=text_channels.count|add:voice_channels.count %}
                <button class="add-channel-btn" 
                        data-bs-toggle="modal" 
                        data-bs-target="#createTextChannelModal"
                        {% if total_channels >= 100 %}disabled title="{% trans 'Maximum 100 channels reached' %}"{% endif %}>
                    <i class="fas fa-plus"></i>
                </button>
                {% endwith %}
                {% endif %}
            </div>
            <ul class="channel-list">
                {% for channel in text_channels %}
                <li class="channel-item">
                    <a href="#" class="channel-link" data-channel-type="text" data-channel-slug="{{ channel.slug }}" data-channel-name="{{ channel.name }}">
                        <i class="fas fa-hashtag"></i>
                        {{ channel.name }}
                    </a>
                </li>
                {% empty %}
                <li class="channel-item">
                    <span style="color: #64748b; font-size: 0.9rem;">{% trans "No text channels" %}</span>
                </li>
                {% endfor %}
            </ul>
        </div>
        
        <!-- Voice Channels -->
        <div class="channel-section">
            <div class="channel-section-header">
                <div class="channel-section-title">
                    <i class="fas fa-volume-up"></i> {% trans "VOICE CHANNELS" %}
                    <span class="channel-count">({{ voice_channels.count }})</span>
                </div>
                {% if is_owner %}
                {% with total_channels=text_channels.count|add:voice_channels.count %}
                <button class="add-channel-btn" 
                        data-bs-toggle="modal" 
                        data-bs-target="#createVoiceChannelModal"
                        {% if total_channels >= 100 %}disabled title="{% trans 'Maximum 100 channels reached' %}"{% endif %}>
                    <i class="fas fa-plus"></i>
                </button>
                {% endwith %}
                {% endif %}
            </div>
            <ul class="channel-list">
                {% for channel in voice_channels %}
                <li class="channel-item">
                    <a href="#" class="channel-link" data-channel-type="voice" data-channel-slug="{{ channel.slug }}" data-channel-name="{{ channel.name }}">
                        <i class="fas fa-volume-up"></i>
                        {{ channel.name }}
                    </a>
                </li>
                {% empty %}
                <li class="channel-item">
                    <span style="color: #64748b; font-size: 0.9rem;">{% trans "No voice channels" %}</span>
                </li>
                {% endfor %}
            </ul>
        </div>
        
        <!-- Channel Count Display -->
        {% if is_owner %}
        <div style="padding: 1rem; background: rgba(102, 126, 234, 0.1); border-radius: 10px; margin-top: 1rem; text-align: center;">
            <div style="color: #667eea; font-size: 0.85rem; font-weight: 600;">
                {% with total_channels=text_channels.count|add:voice_channels.count %}
                {% trans "Channels" %}: {{ total_channels }}/100
                {% endwith %}
            </div>
        </div>
        {% endif %}
    </div>
    
    <!-- Main Content -->
    <div class="main-content">
        <div class="server-header">
            <div class="server-icon-large">
                {{ server.icon|default:"ðŸŽ®" }}
            </div>
            <div class="server-info">
                <h2>
                    {{ server.name }}
                    {% if is_owner %}
                    <span class="badge bg-warning text-dark ms-2">
                        <i class="fas fa-crown"></i> {% trans "Owner" %}
                    </span>
                    {% endif %}
                </h2>
                <p>{{ server.description|default:"No description" }}</p>
                {% if user_roles %}
                <div>
                    {% for role in user_roles %}
                    <span class="role-badge">
                        {{ role.name }}
                    </span>
                    {% endfor %}
                </div>
                {% endif %}
            </div>
        </div>
        
        <!-- Welcome Message (shown when no channel selected) -->
        <div class="welcome-message" id="welcome-message">
            <div class="welcome-icon">
                <i class="fas fa-comments"></i>
            </div>
            <h3 class="welcome-title">{% trans "Welcome to" %} {{ server.name }}!</h3>
            <p class="welcome-text">
                {% trans "Select a channel from the sidebar to start chatting." %}
            </p>
        </div>
        
        <!-- Chat Area (hidden by default, shown when text channel selected) -->
        <div id="chat-area" class="hidden" style="display: none; flex-direction: column; height: calc(100vh - 200px);">
            <!-- Chat Header -->
            <div style="padding: 1rem; border-bottom: 1px solid rgba(148, 163, 184, 0.2); display: flex; align-items: center; gap: 1rem;">
                <i class="fas fa-hashtag" style="color: #94a3b8;"></i>
                <h4 style="margin: 0; color: #f1f5f9; font-weight: 600;" id="chat-channel-name">{% trans "Channel" %}</h4>
            </div>
            
            <!-- Messages Container -->
            <div id="discord-messages" style="flex: 1; overflow-y: auto; padding: 1.5rem; background: rgba(15, 23, 42, 0.3);">
                <!-- Messages will be loaded here -->
            </div>
            
            <!-- Chat Input -->
            <div style="padding: 1rem; border-top: 1px solid rgba(148, 163, 184, 0.2);">
                <div style="display: flex; align-items: center; gap: 0.75rem; background: rgba(30, 41, 59, 0.8); padding: 0.75rem; border-radius: 10px;">
                    <button class="btn btn-sm" style="background: transparent; border: none; color: #94a3b8;">
                        <i class="fas fa-plus-circle"></i>
                    </button>
                    <input type="text" id="discord-chat-input" 
                           style="flex: 1; background: transparent; border: none; outline: none; color: #f1f5f9; padding: 0.5rem;"
                           placeholder="{% trans 'Type a message...' %}" autocomplete="off">
                    <button onclick="sendChatMessage()" class="btn btn-sm" style="background: transparent; border: none; color: #94a3b8;">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Voice Area (hidden by default, shown when voice channel selected) -->
        <div id="voice-stage" class="hidden" style="display: none; flex-direction: column; height: calc(100vh - 200px); background: #000; border-radius: 15px; position: relative; overflow: hidden;">
            <!-- Voice Header -->
            <div style="padding: 1rem; border-bottom: 1px solid rgba(148, 163, 184, 0.2); display: flex; align-items: center; justify-content: space-between; background: rgba(15, 23, 42, 0.5);">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <i class="fas fa-volume-up" style="color: #94a3b8;"></i>
                    <h4 style="margin: 0; color: #f1f5f9; font-weight: 600;" id="voice-channel-name">{% trans "Voice Channel" %}</h4>
                </div>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="btn btn-sm" style="background: rgba(30, 41, 59, 0.8); border: none; color: #f1f5f9;">
                        <i class="fas fa-th-large"></i> {% trans "Grid" %}
                    </button>
                </div>
            </div>
            
            <!-- Pinned Participant View (Large) -->
            <div id="pinned-view" class="hidden" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #000; z-index: 15; border: 3px solid #667eea; border-radius: 15px;">
                <div style="position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                    <video id="pinned-video" autoplay playsInline style="width: 100%; height: 100%; object-fit: contain;"></video>
                    <div style="position: absolute; top: 1rem; right: 1rem; display: flex; gap: 0.5rem;">
                        <button onclick="unpinParticipant()" class="btn" style="background: rgba(30, 41, 59, 0.9); border: none; color: #f1f5f9; padding: 0.5rem 1rem; border-radius: 8px;">
                            <i class="fas fa-times"></i> {% trans "Unpin" %}
                        </button>
                    </div>
                    <div style="position: absolute; bottom: 1rem; left: 1rem; background: rgba(0, 0, 0, 0.7); padding: 0.75rem 1.25rem; border-radius: 10px; color: #f1f5f9; font-weight: 600;" id="pinned-username">
                        <!-- Pinned user name -->
                    </div>
                </div>
            </div>
            
            <!-- Video Grid -->
            <div id="video-grid" style="flex: 1; display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; padding: 1.5rem; overflow-y: auto; position: relative;">
                <!-- Participants will be added here -->
            </div>
            
            <!-- Screen Share Container (Separate overlay, doesn't block camera) -->
            <div id="screen-share-container" class="hidden" style="display: none; position: absolute; top: 2rem; right: 2rem; width: 400px; height: 300px; background: #000; z-index: 12; border: 2px solid #667eea; border-radius: 15px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);">
                <div style="position: relative; width: 100%; height: 100%;">
                    <video id="screen-share-video" autoplay playsInline style="width: 100%; height: 100%; object-fit: contain; border-radius: 15px;"></video>
                    <button onclick="toggleScreenShare()" style="position: absolute; top: 0.5rem; right: 0.5rem; background: rgba(239, 68, 68, 0.9); border: none; color: white; padding: 0.5rem; border-radius: 50%; width: 32px; height: 32px; cursor: pointer;">
                        <i class="fas fa-times"></i>
                    </button>
                    <div style="position: absolute; bottom: 0.5rem; left: 0.5rem; background: rgba(0, 0, 0, 0.7); padding: 0.5rem 0.75rem; border-radius: 8px; color: #f1f5f9; font-size: 0.85rem; font-weight: 600;">
                        <i class="fas fa-desktop"></i> {% trans "Screen Share" %}
                    </div>
                </div>
            </div>
            
            <!-- Voice Controls -->
            <div style="position: absolute; bottom: 1.5rem; left: 50%; transform: translateX(-50%); background: rgba(30, 41, 59, 0.95); padding: 1rem 2rem; border-radius: 50px; display: flex; gap: 1rem; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); z-index: 20;">
                <button id="mic-btn" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: rgba(100, 116, 139, 0.6); border: none; color: #f1f5f9;">
                    <i class="fas fa-microphone"></i>
                </button>
                <button id="video-btn" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: rgba(100, 116, 139, 0.6); border: none; color: #f1f5f9;">
                    <i class="fas fa-video"></i>
                </button>
                <button onclick="toggleScreenShare()" id="screen-share-btn" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: rgba(100, 116, 139, 0.6); border: none; color: #f1f5f9;">
                    <i class="fas fa-desktop"></i>
                </button>
                <button onclick="leaveVoiceChannel()" class="btn" style="width: 50px; height: 50px; border-radius: 50%; background: #ef4444; border: none; color: #f1f5f9;">
                    <i class="fas fa-phone-slash"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Members Sidebar -->
    <div class="members-sidebar">
        <div class="members-section-title">
            <span>{% trans "MEMBERS" %} â€” {{ members.count }}</span>
        </div>
        <div>
            {% for member in members %}
            <div class="member-item">
                <div class="member-avatar">
                    {{ member.get_display_name|first|upper }}
                </div>
                <div class="member-info">
                    <div class="member-name">
                        {{ member.get_display_name }}
                        {% if member.user == server.owner %}
                        <i class="fas fa-crown text-warning ms-1" style="font-size: 0.7rem;"></i>
                        {% endif %}
                    </div>
                    <div class="member-status">
                        {% if member.is_online %}
                        <span class="online-indicator"></span>{% trans "Online" %}
                        {% else %}
                        <span style="color: #64748b;">{% trans "Offline" %}</span>
                        {% endif %}
                    </div>
                </div>
            </div>
            {% empty %}
            <p style="color: #64748b; font-size: 0.9rem; text-align: center; padding: 1rem;">{% trans "No members" %}</p>
            {% endfor %}
        </div>
    </div>
</div>

<!-- Create Text Channel Modal -->
{% if is_owner %}
<div class="modal fade" id="createTextChannelModal" tabindex="-1" aria-labelledby="createTextChannelModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createTextChannelModalLabel">
                    <i class="fas fa-hashtag me-2"></i>{% trans "Create Text Channel" %}
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form method="post" action="{% url 'create_text_channel' server_slug=server.slug %}">
                {% csrf_token %}
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="textChannelName" class="form-label">{% trans "Channel Name" %}</label>
                        <input type="text" class="form-control" id="textChannelName" name="name" 
                               placeholder="{% trans 'general' %}" required maxlength="100">
                    </div>
                    <div class="mb-3">
                        <label for="textChannelDescription" class="form-label">{% trans "Description" %} ({% trans "Optional" %})</label>
                        <textarea class="form-control" id="textChannelDescription" name="description" 
                                  rows="3" placeholder="{% trans 'Channel description...' %}"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="textChannelPosition" class="form-label">{% trans "Position" %}</label>
                        <input type="number" class="form-control" id="textChannelPosition" name="position" 
                               value="0" min="0">
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="textChannelPrivate" name="is_private">
                        <label class="form-check-label" for="textChannelPrivate">
                            {% trans "Private Channel" %}
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{% trans "Cancel" %}</button>
                    <button type="submit" class="btn btn-primary">
                        <i class="fas fa-plus me-2"></i>{% trans "Create Channel" %}
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<!-- Create Voice Channel Modal -->
<div class="modal fade" id="createVoiceChannelModal" tabindex="-1" aria-labelledby="createVoiceChannelModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="createVoiceChannelModalLabel">
                    <i class="fas fa-volume-up me-2"></i>{% trans "Create Voice Channel" %}
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <form method="post" action="{% url 'create_voice_channel' server_slug=server.slug %}">
                {% csrf_token %}
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="voiceChannelName" class="form-label">{% trans "Channel Name" %}</label>
                        <input type="text" class="form-control" id="voiceChannelName" name="name" 
                               placeholder="{% trans 'General' %}" required maxlength="100">
                    </div>
                    <div class="mb-3">
                        <label for="voiceChannelDescription" class="form-label">{% trans "Description" %} ({% trans "Optional" %})</label>
                        <textarea class="form-control" id="voiceChannelDescription" name="description" 
                                  rows="3" placeholder="{% trans 'Channel description...' %}"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="voiceChannelPosition" class="form-label">{% trans "Position" %}</label>
                        <input type="number" class="form-control" id="voiceChannelPosition" name="position" 
                               value="0" min="0">
                    </div>
                    <div class="mb-3">
                        <label for="voiceChannelUserLimit" class="form-label">{% trans "User Limit" %} (0 = {% trans "Unlimited" %})</label>
                        <input type="number" class="form-control" id="voiceChannelUserLimit" name="user_limit" 
                               value="0" min="0" max="99">
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="voiceChannelPrivate" name="is_private">
                        <label class="form-check-label" for="voiceChannelPrivate">
                            {% trans "Private Channel" %}
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">{% trans "Cancel" %}</button>
                    <button type="submit" class="btn btn-primary">
                        <i class="fas fa-plus me-2"></i>{% trans "Create Channel" %}
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
<script>
    // Get COTURN settings from backend (one server handles all voice channels)
    const coturnConfig = JSON.parse('{{ coturn_config_json|escapejs }}');
    
    // COTURN Configuration for WebRTC
    // One COTURN server can handle multiple voice channels - it's just for NAT traversal
    const iceServers = [
        { urls: coturnConfig.stun_url || 'stun:31.58.244.167:3478' },
        {
            urls: coturnConfig.turn_url || 'turn:31.58.244.167:3478',
            username: coturnConfig.turn_username || 'adem',
            credential: coturnConfig.turn_credential || 'fb1907'
        },
        { urls: coturnConfig.stun_url_2 || 'stun:stun.l.google.com:19302' }
    ];
    
    console.log('COTURN Configuration (backend):', iceServers);
    
    let currentChannelSlug = null;
    let currentChannelType = null; // 'text' or 'voice'
    let chatSocket = null;
    let localStream = null;
    let peerConnections = {};
    let isMuted = false;
    let isVideoEnabled = true;
    let audioAnalyzers = {}; // Store audio analyzers for voice activity detection
    let pinnedParticipant = null; // Currently pinned participant
    let screenShareStream = null; // Screen share stream (separate from camera)
    
    const messageList = document.getElementById('discord-messages');
    const chatInput = document.getElementById('discord-chat-input');
    const welcomeMessage = document.getElementById('welcome-message');
    const chatArea = document.getElementById('chat-area');
    const voiceStage = document.getElementById('voice-stage');
    
    // Handle channel clicks
    document.querySelectorAll('.channel-link').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const channelType = this.getAttribute('data-channel-type');
            const channelSlug = this.getAttribute('data-channel-slug');
            const channelName = this.getAttribute('data-channel-name');
            
            // Update active state
            document.querySelectorAll('.channel-link').forEach(l => l.parentElement.classList.remove('active'));
            this.parentElement.classList.add('active');
            
            if (channelType === 'text') {
                openTextChannel(channelSlug, channelName);
            } else if (channelType === 'voice') {
                openVoiceChannel(channelSlug, channelName);
            }
        });
    });
    
    function openTextChannel(slug, name) {
        // Clean up voice channel if switching from voice
        if (currentChannelType === 'voice') {
            cleanupVoiceChannel();
        }
        
        currentChannelSlug = slug;
        currentChannelType = 'text';
        
        // Close previous WebSocket connection
        if (chatSocket) {
            chatSocket.close();
            chatSocket = null;
        }
        
        // Update UI
        welcomeMessage.style.display = 'none';
        voiceStage.style.display = 'none';
        chatArea.style.display = 'flex';
        document.getElementById('chat-channel-name').textContent = name;
        
        // Clear messages before loading new ones
        if (messageList) {
            messageList.innerHTML = '';
        }
        
        // Connect WebSocket and load history
        connectWebSocket();
        loadChatHistory();
    }
    
    function openVoiceChannel(slug, name) {
        // Clean up previous voice channel first
        cleanupVoiceChannel();
        
        currentChannelSlug = slug;
        currentChannelType = 'voice';
        
        // Update UI
        welcomeMessage.style.display = 'none';
        chatArea.style.display = 'none';
        voiceStage.style.display = 'flex';
        document.getElementById('voice-channel-name').textContent = name;
        
        // Clear video grid
        const videoGrid = document.getElementById('video-grid');
        videoGrid.innerHTML = '';
        
        // Initialize voice
        initializeVoice();
    }
    
    function cleanupVoiceChannel() {
        // Stop local stream
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }
        
        // Close all peer connections
        Object.values(peerConnections).forEach(pc => {
            pc.close();
        });
        peerConnections = {};
        
        // Clear ICE candidate queue
        Object.keys(iceCandidateQueue).forEach(username => {
            delete iceCandidateQueue[username];
        });
        
        // Stop all audio analyzers
        Object.values(audioAnalyzers).forEach(analyzer => {
            if (analyzer.stop) analyzer.stop();
        });
        audioAnalyzers = {};
        
        // Clean up remote streams
        if (window.remoteStreams) {
            Object.values(window.remoteStreams).forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
            });
            window.remoteStreams = {};
        }
        
        // Unpin if pinned
        if (pinnedParticipant) {
            unpinParticipant();
        }
        
        // Stop screen share
        if (screenShareStream) {
            screenShareStream.getTracks().forEach(track => track.stop());
            screenShareStream = null;
        }
        
        // Close WebSocket if open
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.close();
        }
        
        // Clear video grid
        const videoGrid = document.getElementById('video-grid');
        if (videoGrid) {
            videoGrid.innerHTML = '';
        }
        
        // Reset states
        isMuted = false;
        isVideoEnabled = true;
    }
    
    // WebSocket for chat
    function connectWebSocket() {
        if (!currentChannelSlug || currentChannelType !== 'text') return;
        
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // Add channel_type parameter to disambiguate between TextChannel and VoiceChannel with same slug
        const wsUrl = `${wsProtocol}//${window.location.host}/ws/voice/?channel_slug=${currentChannelSlug}&channel_type=text`;
        
        if (chatSocket) {
            chatSocket.close();
        }
        
        chatSocket = new WebSocket(wsUrl);
        
        chatSocket.onopen = function() {
            console.log("WebSocket Connected");
        };
        
        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            // Only handle chat messages for text channels
            // Don't show system_notification for text channels (prevents "joined room" spam)
            if (data.type === 'chat_message') {
                addMessageToList(data.username, data.message, data.timestamp);
            }
            // Ignore system_notification for text channels
        };
        
        chatSocket.onclose = function() {
            console.log("WebSocket Disconnected");
            if (currentChannelType === 'text') {
                setTimeout(connectWebSocket, 3000);
            }
        };
        
        chatSocket.onerror = function(error) {
            console.error("WebSocket Error:", error);
        };
    }
    
    function addMessageToList(username, content, timestamp) {
        const div = document.createElement('div');
        div.style.cssText = 'display: flex; gap: 1rem; padding: 0.75rem; margin-bottom: 0.5rem; border-radius: 8px; transition: background 0.2s;';
        div.className = 'message-item';
        
        const date = timestamp ? new Date(timestamp) : new Date();
        const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        
        div.innerHTML = `
            <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=random" 
                 style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
            <div style="flex: 1;">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
                    <span style="color: #f1f5f9; font-weight: 600;">${escapeHtml(username)}</span>
                    <span style="color: #64748b; font-size: 0.85rem;">${timeStr}</span>
                </div>
                <p style="color: #cbd5e1; margin: 0;">${escapeHtml(content)}</p>
            </div>
        `;
        
        messageList.appendChild(div);
        messageList.scrollTop = messageList.scrollHeight;
    }
    
    function addSystemMessage(message) {
        const div = document.createElement('div');
        div.style.cssText = 'text-align: center; color: #64748b; padding: 0.5rem; font-size: 0.9rem;';
        div.textContent = message;
        messageList.appendChild(div);
        messageList.scrollTop = messageList.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function sendChatMessage() {
        const message = chatInput.value.trim();
        if (!message || !chatSocket || chatSocket.readyState !== WebSocket.OPEN) return;
        
        chatSocket.send(JSON.stringify({
            signal_type: 'chat_message',
            data: message
        }));
        
        chatInput.value = '';
    }
    
    if (chatInput) {
        chatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatMessage();
            }
        });
    }
    
    async function loadChatHistory() {
        if (!currentChannelSlug) return;
        
        try {
            const response = await fetch(`/api/chat/${currentChannelSlug}/messages/`);
            const data = await response.json();
            
            messageList.innerHTML = '';
            data.messages.forEach(msg => {
                addMessageToList(msg.author, msg.content, msg.timestamp);
            });
        } catch (error) {
            console.error("Error loading chat history:", error);
        }
    }
    
    // Voice functionality
    async function initializeVoice() {
        try {
            console.log("Initializing voice channel...");
            
            // Request media access first
            localStream = await navigator.mediaDevices.getUserMedia({ 
                audio: true, 
                video: isVideoEnabled  // Use the current video state
            });
            
            console.log("Media stream obtained:", localStream.getTracks().length, "tracks");
            
            // Connect to WebSocket FIRST (before adding user to grid)
            // This ensures we're in the channel group when we appear
            connectVoiceWebSocket();
            
            // Add local user to video grid after connecting
            // Wait a bit for WebSocket to connect
            setTimeout(() => {
                // Add local user to video grid with video element if camera is on
                addParticipantToGrid('{{ user.username }}', localStream, true);
                
                // If video is enabled, show it (full cover)
                if (isVideoEnabled && localStream.getVideoTracks().length > 0) {
                    const participantDiv = document.getElementById('participant-{{ user.username }}');
                    if (participantDiv) {
                        const videoContainer = participantDiv.querySelector('.participant-video-container');
                        const avatar = participantDiv.querySelector('.participant-avatar');
                        
                        if (videoContainer) {
                            if (avatar) avatar.style.display = 'none';
                            
                            let videoElement = participantDiv.querySelector('video');
                            if (!videoElement) {
                                videoElement = document.createElement('video');
                                videoElement.id = 'video-{{ user.username }}';
                                videoElement.className = 'participant-video';
                                videoElement.autoplay = true;
                                videoElement.playsInline = true;
                                videoElement.muted = true; // Mute own video
                                videoElement.style.cssText = 'width: 100%; height: 100%; min-height: 200px; object-fit: cover; border-radius: 15px; position: absolute; inset: 0; z-index: 1;';
                                videoContainer.appendChild(videoElement);
                            }
                            
                            videoElement.srcObject = localStream;
                            videoElement.play().catch(err => {
                                console.warn('Error playing local video:', err);
                            });
                        }
                    }
                }
                
                // Setup VAD for local user
                if (localStream && localStream.getAudioTracks().length > 0) {
                    setupVoiceActivityDetection('{{ user.username }}', localStream);
                }
                
                console.log('Voice channel fully initialized');
            }, 500);
            
        } catch (error) {
            console.error("Error accessing media devices:", error);
            alert("{% trans 'Could not access microphone/camera. Please check permissions.' %}");
            // Still try to connect WebSocket even if media fails
            connectVoiceWebSocket();
        }
    }
    
    function connectVoiceWebSocket() {
        if (!currentChannelSlug || currentChannelType !== 'voice') {
            console.warn("Cannot connect: missing channel slug or not voice channel");
            return;
        }
        
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // Add channel_type parameter to disambiguate between TextChannel and VoiceChannel with same slug
        const wsUrl = `${wsProtocol}//${window.location.host}/ws/voice/?channel_slug=${currentChannelSlug}&channel_type=voice`;
        
        console.log("Connecting to voice WebSocket:", wsUrl);
        
        // Close existing socket if open (to create fresh connection for voice)
        if (chatSocket) {
            chatSocket.onerror = null;
            chatSocket.onclose = null;
            chatSocket.close();
            chatSocket = null;
        }
        
        // Create new WebSocket connection for voice channel
        try {
            chatSocket = new WebSocket(wsUrl);
        } catch (error) {
            console.error("Failed to create WebSocket:", error);
            alert("Failed to connect to voice channel. Please refresh and try again.");
            return;
        }
        
        chatSocket.onopen = function() {
            console.log("Voice WebSocket Connected successfully");
            // Notify that connection is ready
            if (currentChannelType === 'voice') {
                console.log("Ready for voice communication");
                // After connection, if we have local stream, we're ready to receive offers
                // The member_joined events will trigger peer connection creation
            }
        };
        
        chatSocket.onerror = function(error) {
            console.error("Voice WebSocket Error:", error);
            // Try to reconnect after a delay
            if (currentChannelType === 'voice') {
                setTimeout(() => {
                    if (currentChannelType === 'voice' && (!chatSocket || chatSocket.readyState === WebSocket.CLOSED)) {
                        console.log("Attempting to reconnect voice WebSocket...");
                        connectVoiceWebSocket();
                    }
                }, 3000);
            }
        };
        
        chatSocket.onclose = function(event) {
            console.log("Voice WebSocket Closed", event.code, event.reason);
            // Try to reconnect if we're still in a voice channel
            if (currentChannelType === 'voice' && currentChannelSlug) {
                console.log("Attempting to reconnect voice WebSocket in 2 seconds...");
                setTimeout(() => {
                    if (currentChannelType === 'voice' && currentChannelSlug) {
                        connectVoiceWebSocket();
                    }
                }, 2000);
            }
        };
        
        chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            
            // Handle member joined event (only for voice channels)
            if (data.type === 'system_notification' && data.event === 'member_joined') {
                console.log('Member joined voice channel:', data.username, 'ID:', data.sender_id);
                // Store user_id mapping
                if (data.sender_id) {
                    userIdMap[data.username] = data.sender_id;
                }
                
                // Add the new member to the grid if not already present and not self
                if (data.username !== '{{ user.username }}') {
                    // Check if participant already exists
                    let participantDiv = document.getElementById(`participant-${data.username}`);
                    if (!participantDiv) {
                        // Add new participant with placeholder avatar
                        participantDiv = addParticipantToGrid(data.username, null, false);
                        console.log(`Added ${data.username} to voice grid`);
                    } else {
                        console.log(`${data.username} already in grid`);
                    }
                    
                    // Create WebRTC peer connection for the new user (only if we have local stream)
                    // This ensures mesh topology - everyone connects to everyone
                    if (localStream) {
                        // Wait a bit to ensure WebSocket is ready
                        setTimeout(() => {
                            createPeerConnection(data.username, data.sender_id);
                        }, 200);
                    } else {
                        console.log('Waiting for local stream before creating peer connection');
                    }
                } else {
                    // When we join, we need to create connections with existing users
                    // This will be handled when existing users send us offers
                    console.log('I joined the channel, waiting for offers from existing users');
                }
            }
            
            // Handle member left event (only for voice channels)
            if (data.type === 'system_notification' && data.event === 'member_left') {
                console.log('Member left voice channel:', data.username);
                
                // Stop voice activity detection
                if (audioAnalyzers[data.username]) {
                    if (audioAnalyzers[data.username].stop) {
                        audioAnalyzers[data.username].stop();
                    }
                    delete audioAnalyzers[data.username];
                }
                
                // Unpin if this was the pinned participant
                if (pinnedParticipant === data.username) {
                    unpinParticipant();
                }
                
                // Close peer connection
                if (peerConnections[data.username]) {
                    peerConnections[data.username].close();
                    delete peerConnections[data.username];
                    console.log(`Closed peer connection with ${data.username}`);
                }
                
                // Remove the member from the grid
                const participantDiv = document.getElementById(`participant-${data.username}`);
                if (participantDiv) {
                    participantDiv.remove();
                    console.log(`Removed ${data.username} from voice grid`);
                }
            }
            
            // Handle microphone state changes from other users
            if (data.type === 'mic_state_change' && data.data) {
                updateParticipantMicState(data.data.username, !data.data.muted);
            }
            
            // Handle camera state changes from other users
            if (data.type === 'camera_state_change' && data.data) {
                updateParticipantVideoState(data.data.username, data.data.enabled);
            }
            
            // Handle WebRTC signaling for peer-to-peer connections
            // Process signals that are for us (recipient_id matches) or from other users (not from ourselves)
            if (data.type === 'webrtc_signal') {
                const currentUserId = String('{{ user.id }}');
                const recipientId = String(data.recipient_id || '');
                const senderId = String(data.sender_id || '');
                
                console.log('WebRTC signal received:', {
                    type: data.signal_type,
                    from: senderId,
                    to: recipientId,
                    currentUser: currentUserId
                });
                
                // Process if: signal is for us OR signal is from someone else (not from ourselves)
                if (recipientId === currentUserId || (senderId !== currentUserId && senderId !== '')) {
                    console.log('Processing WebRTC signal:', data.signal_type);
                    if (data.signal_type === 'offer') {
                        handleWebRTCOffer(data);
                    } else if (data.signal_type === 'answer') {
                        handleWebRTCAnswer(data);
                    } else if (data.signal_type === 'ice_candidate') {
                        handleWebRTCIceCandidate(data);
                    }
                } else {
                    console.log('Ignoring WebRTC signal (not for us)');
                }
            } else if (data.type === 'chat_message') {
                // Can receive chat messages in voice channels too
                console.log('Chat message in voice channel:', data);
            } else {
                // Log any other message types for debugging
                console.log('Received voice channel message:', data);
            }
        };
    }
    
    // ========== WebRTC Peer-to-Peer Functions ==========
    
    // Store user_id mapping (username -> user_id from server)
    const userIdMap = {};
    
    // Queue for ICE candidates that arrive before peer connections are created
    const iceCandidateQueue = {};
    
    // Create a peer connection for a user
    async function createPeerConnection(username, senderId) {
        // Don't create connection if it already exists
        if (peerConnections[username]) {
            console.log(`Peer connection with ${username} already exists`);
            return;
        }
        
        if (!localStream) {
            console.warn('Cannot create peer connection: no local stream');
            return;
        }
        
        console.log(`Creating peer connection with ${username} (ID: ${senderId})`);
        
        // Create RTCPeerConnection with COTURN servers
        const pc = new RTCPeerConnection({
            iceServers: iceServers,
            iceTransportPolicy: 'all'
        });
        
        // Add local stream tracks to peer connection
        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
            console.log(`Added ${track.kind} track to peer connection`);
        });
        
        // Store remote streams per user to accumulate all tracks
        if (!window.remoteStreams) {
            window.remoteStreams = {};
        }
        if (!window.remoteStreams[username]) {
            window.remoteStreams[username] = new MediaStream();
        }
        
        // Handle remote stream
        pc.ontrack = (event) => {
            console.log(`Received remote ${event.track.kind} track from ${username}`, {
                trackId: event.track.id,
                trackKind: event.track.kind,
                trackEnabled: event.track.enabled,
                trackReadyState: event.track.readyState,
                streams: event.streams.length
            });
            
            // Get or create remote stream for this user
            let remoteStream = window.remoteStreams[username];
            if (!remoteStream) {
                remoteStream = new MediaStream();
                window.remoteStreams[username] = remoteStream;
            }
            
            // Add the new track to the stream if not already present
            if (!remoteStream.getTracks().some(t => t.id === event.track.id)) {
                remoteStream.addTrack(event.track);
                console.log(`Added ${event.track.kind} track to remote stream for ${username}. Total tracks:`, {
                    audio: remoteStream.getAudioTracks().length,
                    video: remoteStream.getVideoTracks().length
                });
            }
            
            // Use setTimeout to ensure DOM is stable
            setTimeout(() => {
                const participantDiv = document.getElementById(`participant-${username}`);
                if (!participantDiv) {
                    console.warn(`No participant div found for ${username}, creating one...`);
                    addParticipantToGrid(username, null, false);
                    return;
                }
                
                // Check if video element exists, if not create one
                const videoContainer = participantDiv.querySelector('.participant-video-container');
                if (!videoContainer) return;
                
                let videoElement = participantDiv.querySelector('video');
                if (!videoElement) {
                    const avatar = participantDiv.querySelector('.participant-avatar');
                    // Hide avatar when video appears
                    if (avatar) avatar.style.display = 'none';
                    
                    videoElement = document.createElement('video');
                    videoElement.id = `video-${username}`;
                    videoElement.className = 'participant-video';
                    videoElement.autoplay = true;
                    videoElement.playsInline = true;
                    videoElement.muted = false;
                    videoElement.volume = 1.0; // Ensure audio is at full volume
                    // Full cover video
                    videoElement.style.cssText = 'width: 100%; height: 100%; min-height: 200px; object-fit: cover; border-radius: 15px; position: absolute; inset: 0; z-index: 1;';
                    videoContainer.appendChild(videoElement);
                    console.log(`Created video element for ${username}`);
                }
                
                if (videoElement && document.body.contains(videoElement)) {
                    // Always update srcObject with the accumulated stream
                    videoElement.srcObject = remoteStream;
                    
                    // Log track information
                    console.log(`Setting stream for ${username}:`, {
                        audioTracks: remoteStream.getAudioTracks().length,
                        videoTracks: remoteStream.getVideoTracks().length,
                        audioEnabled: remoteStream.getAudioTracks().every(t => t.enabled),
                        videoEnabled: remoteStream.getVideoTracks().every(t => t.enabled)
                    });
                    
                    // Initialize voice activity detection if we have audio
                    if (remoteStream.getAudioTracks().length > 0 && !audioAnalyzers[username]) {
                        setupVoiceActivityDetection(username, remoteStream);
                    }
                    
                    // Ensure video plays - check if element still exists
                    requestAnimationFrame(() => {
                        if (videoElement && document.body.contains(videoElement)) {
                            videoElement.play().then(() => {
                                console.log(`Video/audio playing for ${username}`);
                            }).catch(err => {
                                if (err.name !== 'AbortError' && err.name !== 'NotAllowedError') {
                                    console.error(`Error playing video/audio for ${username}:`, err);
                                }
                            });
                        }
                    });
                    console.log(`Connected remote stream from ${username} with ${remoteStream.getTracks().length} tracks`);
                }
            }, 100);
        };
        
        // Handle ICE candidates
        pc.onicecandidate = (event) => {
            if (event.candidate) {
                console.log(`Sending ICE candidate to ${username} (ID: ${senderId})`);
                if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                    chatSocket.send(JSON.stringify({
                        signal_type: 'ice_candidate',
                        recipient_id: String(senderId),
                        data: {
                            candidate: event.candidate.candidate,
                            sdpMLineIndex: event.candidate.sdpMLineIndex,
                            sdpMid: event.candidate.sdpMid
                        }
                    }));
                } else {
                    console.warn('WebSocket not open, cannot send ICE candidate');
                }
            } else {
                console.log(`ICE gathering complete for ${username}`);
            }
        };
        
        // Handle connection state changes
        pc.onconnectionstatechange = () => {
            console.log(`Connection state with ${username}:`, pc.connectionState);
            if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                console.warn(`Connection with ${username} failed or disconnected`);
            }
        };
        
        // Store peer connection
        peerConnections[username] = pc;
        
        // Process any queued ICE candidates now that peer connection exists
        if (iceCandidateQueue[username] && iceCandidateQueue[username].length > 0) {
            console.log(`Processing ${iceCandidateQueue[username].length} queued ICE candidates for ${username}`);
            const queue = iceCandidateQueue[username];
            iceCandidateQueue[username] = []; // Clear queue
            
            // Wait a bit for local description to be set
            setTimeout(async () => {
                for (const queuedCandidate of queue) {
                    try {
                        await pc.addIceCandidate(new RTCIceCandidate({
                            candidate: queuedCandidate.candidate,
                            sdpMLineIndex: queuedCandidate.sdpMLineIndex,
                            sdpMid: queuedCandidate.sdpMid
                        }));
                        console.log(`Added queued ICE candidate from ${username}`);
                    } catch (error) {
                        console.warn(`Error adding queued ICE candidate from ${username}:`, error.message);
                    }
                }
            }, 200);
        }
        
        // If we're the one initiating (new user joined after us), create and send offer
        // This creates a mesh topology - everyone connects to everyone
        try {
            const offerOptions = {
                offerToReceiveAudio: true,
                offerToReceiveVideo: true
            };
            
            const offer = await pc.createOffer(offerOptions);
            await pc.setLocalDescription(offer);
            console.log(`Created offer for ${username}, sending...`);
            
            // Wait a bit to ensure local description is set
            await new Promise(resolve => setTimeout(resolve, 100));
            
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    signal_type: 'offer',
                    recipient_id: String(senderId),
                    data: {
                        sdp: offer.sdp,
                        type: offer.type
                    }
                }));
                console.log(`Offer sent to ${username} (ID: ${senderId})`);
            } else {
                console.warn('WebSocket not open, will retry offer...');
                // Retry after delay
                setTimeout(async () => {
                    if (chatSocket && chatSocket.readyState === WebSocket.OPEN && peerConnections[username]) {
                        try {
                            const retryOffer = await peerConnections[username].createOffer(offerOptions);
                            await peerConnections[username].setLocalDescription(retryOffer);
                            chatSocket.send(JSON.stringify({
                                signal_type: 'offer',
                                recipient_id: String(senderId),
                                data: {
                                    sdp: retryOffer.sdp,
                                    type: retryOffer.type
                                }
                            }));
                            console.log(`Offer sent to ${username} (retry successful)`);
                        } catch (retryError) {
                            console.error('Error retrying offer:', retryError);
                        }
                    }
                }, 500);
            }
        } catch (error) {
            console.error(`Error creating offer for ${username}:`, error);
        }
    }
    
    // Handle WebRTC offer
    async function handleWebRTCOffer(data) {
        const username = data.username || 'unknown';
        const senderId = String(data.sender_id || '');
        const offer = data.data;
        
        console.log(`Received offer from ${username} (ID: ${senderId})`);
        console.log('Offer data:', offer);
        
        // Ensure participant exists in grid
        let participantDiv = document.getElementById(`participant-${username}`);
        if (!participantDiv) {
            console.log(`Creating participant div for ${username} (from offer)`);
            participantDiv = addParticipantToGrid(username, null, false);
        }
        
        // Create or get peer connection
        let pc = peerConnections[username];
        if (!pc) {
            console.log(`Creating new peer connection for ${username} (from offer)`);
            // Create new peer connection
            if (!localStream) {
                console.warn('Cannot handle offer: no local stream');
                return;
            }
            
            pc = new RTCPeerConnection({
                iceServers: iceServers,
                iceTransportPolicy: 'all'
            });
            
            // Add local tracks
            localStream.getTracks().forEach(track => {
                pc.addTrack(track, localStream);
            });
            
            // Store remote streams per user to accumulate all tracks
            if (!window.remoteStreams) {
                window.remoteStreams = {};
            }
            if (!window.remoteStreams[username]) {
                window.remoteStreams[username] = new MediaStream();
            }
            
            // Set up event handlers
            pc.ontrack = (event) => {
                console.log(`Received remote ${event.track.kind} track from ${username} (from offer)`, {
                    trackId: event.track.id,
                    trackKind: event.track.kind,
                    trackEnabled: event.track.enabled,
                    trackReadyState: event.track.readyState,
                    streams: event.streams.length
                });
                
                // Get or create remote stream for this user
                let remoteStream = window.remoteStreams[username];
                if (!remoteStream) {
                    remoteStream = new MediaStream();
                    window.remoteStreams[username] = remoteStream;
                }
                
                // Add the new track to the stream if not already present
                if (!remoteStream.getTracks().some(t => t.id === event.track.id)) {
                    remoteStream.addTrack(event.track);
                    console.log(`Added ${event.track.kind} track to remote stream for ${username}. Total tracks:`, {
                        audio: remoteStream.getAudioTracks().length,
                        video: remoteStream.getVideoTracks().length
                    });
                    
                    // If video element exists, ensure it's updated and playing
                    const participantDiv = document.getElementById(`participant-${username}`);
                    if (participantDiv) {
                        const videoElement = participantDiv.querySelector('video');
                        if (videoElement && videoElement.srcObject === remoteStream) {
                            // Force play when new track is added
                            requestAnimationFrame(() => {
                                if (videoElement && document.body.contains(videoElement)) {
                                    videoElement.play().then(() => {
                                        console.log(`Video/audio playing after track addition for ${username}`);
                                    }).catch(err => {
                                        if (err.name !== 'AbortError' && err.name !== 'NotAllowedError') {
                                            console.warn(`Play error after track addition for ${username}:`, err.name);
                                        }
                                    });
                                }
                            });
                        }
                    }
                }
                
                setTimeout(() => {
                    const participantDiv = document.getElementById(`participant-${username}`);
                    if (!participantDiv) {
                        console.warn(`No participant div found for ${username}, creating one...`);
                        addParticipantToGrid(username, null, false);
                        return;
                    }
                    
                    const videoContainer = participantDiv.querySelector('.participant-video-container');
                    if (!videoContainer) return;
                    
                    let videoElement = participantDiv.querySelector('video');
                    if (!videoElement) {
                        const avatar = participantDiv.querySelector('.participant-avatar');
                        if (avatar) avatar.style.display = 'none';
                        
                        videoElement = document.createElement('video');
                        videoElement.id = `video-${username}`;
                        videoElement.className = 'participant-video';
                        videoElement.autoplay = true;
                        videoElement.playsInline = true;
                        videoElement.muted = false;
                        videoElement.volume = 1.0; // Ensure audio is at full volume
                        videoElement.style.cssText = 'width: 100%; height: 100%; min-height: 200px; object-fit: cover; border-radius: 15px; position: absolute; inset: 0; z-index: 1;';
                        videoContainer.appendChild(videoElement);
                        console.log(`Created video element for ${username} (from offer)`);
                    }
                    
                    if (videoElement && document.body.contains(videoElement)) {
                        // Always update srcObject with the accumulated stream
                        videoElement.srcObject = remoteStream;
                        
                        // Log track information
                        console.log(`Setting stream for ${username}:`, {
                            audioTracks: remoteStream.getAudioTracks().length,
                            videoTracks: remoteStream.getVideoTracks().length,
                            audioEnabled: remoteStream.getAudioTracks().every(t => t.enabled),
                            videoEnabled: remoteStream.getVideoTracks().every(t => t.enabled)
                        });
                        
                        // Initialize voice activity detection if we have audio
                        if (remoteStream.getAudioTracks().length > 0 && !audioAnalyzers[username]) {
                            setupVoiceActivityDetection(username, remoteStream);
                        }
                        
                        requestAnimationFrame(() => {
                            if (videoElement && document.body.contains(videoElement)) {
                                videoElement.play().then(() => {
                                    console.log(`Video/audio playing for ${username} (from offer)`);
                                }).catch(err => {
                                    if (err.name !== 'AbortError' && err.name !== 'NotAllowedError') {
                                        console.error(`Error playing video/audio for ${username}:`, err);
                                    }
                                });
                            }
                        });
                        console.log(`Connected remote stream from ${username} with ${remoteStream.getTracks().length} tracks`);
                    }
                }, 100);
            };
            
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`Sending ICE candidate to ${username} (ID: ${senderId})`);
                    if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                        chatSocket.send(JSON.stringify({
                            signal_type: 'ice_candidate',
                            recipient_id: String(senderId),
                            data: {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            }
                        }));
                    } else {
                        console.warn('WebSocket not open, cannot send ICE candidate');
                    }
                } else {
                    console.log(`ICE gathering complete for ${username}`);
                }
            };
            
            peerConnections[username] = pc;
        }
        
        // Set remote description and create answer
        try {
            console.log(`Setting remote description (offer) for ${username}...`);
            await pc.setRemoteDescription(new RTCSessionDescription({
                type: offer.type,
                sdp: offer.sdp
            }));
            console.log(`Remote description set, creating answer...`);
            
            const answer = await pc.createAnswer();
            console.log(`Answer created, setting local description...`);
            await pc.setLocalDescription(answer);
            console.log(`Local description set`);
            
            // Process any queued ICE candidates now that peer connection and answer are set
            if (iceCandidateQueue[username] && iceCandidateQueue[username].length > 0) {
                console.log(`Processing ${iceCandidateQueue[username].length} queued ICE candidates for ${username} (after answer)`);
                const queue = iceCandidateQueue[username];
                iceCandidateQueue[username] = []; // Clear queue
                
                // Wait a bit for local description to be fully set
                setTimeout(async () => {
                    for (const queuedCandidate of queue) {
                        try {
                            await pc.addIceCandidate(new RTCIceCandidate({
                                candidate: queuedCandidate.candidate,
                                sdpMLineIndex: queuedCandidate.sdpMLineIndex,
                                sdpMid: queuedCandidate.sdpMid
                            }));
                            console.log(`Added queued ICE candidate from ${username} (after answer)`);
                        } catch (error) {
                            console.warn(`Error adding queued ICE candidate from ${username}:`, error.message);
                        }
                    }
                }, 200);
            }
            
            console.log(`Created answer for ${username}, sending...`);
            
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    signal_type: 'answer',
                    recipient_id: senderId,
                    data: {
                        sdp: answer.sdp,
                        type: answer.type
                    }
                }));
                console.log(`Answer sent to ${username} (ID: ${senderId})`);
            } else {
                console.error('WebSocket not open, cannot send answer');
            }
        } catch (error) {
            console.error(`Error handling offer from ${username}:`, error);
            console.error('Error details:', error.message, error.stack);
        }
    }
    
    // Handle WebRTC answer
    async function handleWebRTCAnswer(data) {
        const username = data.username || 'unknown';
        const answer = data.data;
        
        console.log(`Received answer from ${username}`);
        console.log('Answer data:', answer);
        
        const pc = peerConnections[username];
        if (!pc) {
            console.warn(`No peer connection found for ${username}`);
            return;
        }
        
        try {
            console.log(`Setting remote description (answer) for ${username}...`);
            await pc.setRemoteDescription(new RTCSessionDescription({
                type: answer.type,
                sdp: answer.sdp
            }));
            console.log(`Remote description (answer) set successfully for ${username}`);
        } catch (error) {
            console.error(`Error handling answer from ${username}:`, error);
            console.error('Error details:', error.message, error.stack);
        }
    }
    
    // Handle ICE candidate
    async function handleWebRTCIceCandidate(data) {
        const username = data.username || 'unknown';
        const candidate = data.data;
        
        console.log(`Received ICE candidate from ${username}`);
        
        const pc = peerConnections[username];
        if (!pc) {
            // Queue the candidate if peer connection doesn't exist yet
            if (!iceCandidateQueue[username]) {
                iceCandidateQueue[username] = [];
            }
            iceCandidateQueue[username].push(candidate);
            console.log(`Queued ICE candidate for ${username} (peer connection not ready yet, queue size: ${iceCandidateQueue[username].length})`);
            return;
        }
        
        // Process any queued candidates first
        if (iceCandidateQueue[username] && iceCandidateQueue[username].length > 0) {
            console.log(`Processing ${iceCandidateQueue[username].length} queued ICE candidates for ${username}`);
            const queue = iceCandidateQueue[username];
            iceCandidateQueue[username] = []; // Clear queue
            
            for (const queuedCandidate of queue) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate({
                        candidate: queuedCandidate.candidate,
                        sdpMLineIndex: queuedCandidate.sdpMLineIndex,
                        sdpMid: queuedCandidate.sdpMid
                    }));
                    console.log(`Added queued ICE candidate from ${username}`);
                } catch (error) {
                    console.warn(`Error adding queued ICE candidate from ${username}:`, error.message);
                }
            }
        }
        
        // Process current candidate
        try {
            await pc.addIceCandidate(new RTCIceCandidate({
                candidate: candidate.candidate,
                sdpMLineIndex: candidate.sdpMLineIndex,
                sdpMid: candidate.sdpMid
            }));
            console.log(`Added ICE candidate from ${username}`);
        } catch (error) {
            console.error(`Error adding ICE candidate from ${username}:`, error);
            console.error('Error details:', error.message);
        }
    }
    
    // ========== End WebRTC Functions ==========
    
    function addParticipantToGrid(username, stream, isLocal = false) {
        const videoGrid = document.getElementById('video-grid');
        const participantId = `participant-${username}`;
        
        // Check if participant already exists
        let participantDiv = document.getElementById(participantId);
        if (participantDiv) {
            console.log(`Participant ${username} already exists, updating...`);
            return participantDiv;
        }
        
        participantDiv = document.createElement('div');
        participantDiv.id = participantId;
        participantDiv.dataset.username = username;
        participantDiv.dataset.micMuted = 'false';
        participantDiv.dataset.videoEnabled = 'true';
        participantDiv.dataset.speaking = 'false';
        participantDiv.style.cssText = 'background: rgba(30, 41, 59, 0.8); border-radius: 15px; padding: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; border: 2px solid transparent; overflow: hidden; transition: all 0.3s ease; min-height: 200px;';
        
        // Video container that covers full area
        const videoContainer = document.createElement('div');
        videoContainer.className = 'participant-video-container';
        videoContainer.style.cssText = 'width: 100%; height: 100%; position: relative; display: flex; align-items: center; justify-content: center; min-height: 200px;';
        
        // Speaking indicator (blue glow overlay)
        const speakingIndicator = document.createElement('div');
        speakingIndicator.className = 'speaking-indicator';
        speakingIndicator.style.cssText = 'position: absolute; inset: 0; border: 3px solid transparent; border-radius: 15px; pointer-events: none; opacity: 0; transition: opacity 0.2s ease, box-shadow 0.2s ease; z-index: 5;';
        speakingIndicator.dataset.speaking = 'false';
        
        const avatar = document.createElement('div');
        avatar.className = 'participant-avatar';
        avatar.style.cssText = 'width: 80px; height: 80px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; font-size: 2rem; color: white; font-weight: 700; position: absolute; z-index: 3;';
        avatar.textContent = username.charAt(0).toUpperCase();
        
        // Controls overlay
        const controlsOverlay = document.createElement('div');
        controlsOverlay.className = 'participant-controls';
        controlsOverlay.style.cssText = 'position: absolute; top: 0.5rem; right: 0.5rem; display: flex; gap: 0.5rem; opacity: 0; transition: opacity 0.2s ease; z-index: 10;';
        
        // Pin button
        const pinBtn = document.createElement('button');
        pinBtn.className = 'pin-btn';
        pinBtn.innerHTML = '<i class="fas fa-thumbtack"></i>';
        pinBtn.title = '{% trans "Pin" %}';
        pinBtn.style.cssText = 'background: rgba(30, 41, 59, 0.9); border: none; color: #f1f5f9; padding: 0.5rem; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.85rem;';
        pinBtn.onclick = () => pinParticipant(username);
        controlsOverlay.appendChild(pinBtn);
        
        // Show controls on hover
        participantDiv.addEventListener('mouseenter', () => {
            controlsOverlay.style.opacity = '1';
        });
        participantDiv.addEventListener('mouseleave', () => {
            controlsOverlay.style.opacity = '0';
        });
        
        const nameLabel = document.createElement('div');
        nameLabel.className = 'participant-name-label';
        nameLabel.style.cssText = 'position: absolute; bottom: 0.75rem; left: 0.75rem; background: rgba(0, 0, 0, 0.7); padding: 0.5rem 0.75rem; border-radius: 8px; color: #f1f5f9; font-weight: 600; font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem; z-index: 5;';
        nameLabel.innerHTML = `<i class="fas fa-microphone participant-mic-icon" style="color: #3ba55c;"></i> ${escapeHtml(username)}`;
        
        videoContainer.appendChild(avatar);
        videoContainer.appendChild(speakingIndicator);
        videoContainer.appendChild(controlsOverlay);
        videoContainer.appendChild(nameLabel);
        participantDiv.appendChild(videoContainer);
        videoGrid.appendChild(participantDiv);
        
        return participantDiv;
    }
    
    // Update participant microphone state (visible to everyone)
    function updateParticipantMicState(username, isEnabled) {
        const participantDiv = document.querySelector(`#participant-${username}, [data-username="${username}"]`);
        if (!participantDiv) return;
        
        participantDiv.dataset.micMuted = (!isEnabled).toString();
        const micIcon = participantDiv.querySelector('.participant-mic-icon');
        
        if (micIcon) {
            if (isEnabled) {
                micIcon.className = 'fas fa-microphone participant-mic-icon';
                micIcon.style.color = '#3ba55c';
            } else {
                micIcon.className = 'fas fa-microphone-slash participant-mic-icon';
                micIcon.style.color = '#ef4444';
            }
        }
        
        // Add visual indicator
        if (!isEnabled) {
            participantDiv.style.opacity = '0.7';
        } else {
            participantDiv.style.opacity = '1';
        }
    }
    
    // Update participant camera state (visible to everyone)
    function updateParticipantVideoState(username, isEnabled) {
        const participantDiv = document.querySelector(`#participant-${username}, [data-username="${username}"]`);
        if (!participantDiv) return;
        
        participantDiv.dataset.videoEnabled = isEnabled.toString();
        const avatar = participantDiv.querySelector('.participant-avatar');
        const videoElement = participantDiv.querySelector('video');
        
        if (isEnabled) {
            // Show video, hide avatar
            if (avatar) avatar.style.display = 'none';
            if (videoElement) {
                videoElement.style.display = 'block';
            }
            // Remove camera-off overlay
            const overlay = participantDiv.querySelector('.camera-off-overlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        } else {
            // Hide video, show avatar
            if (videoElement) {
                videoElement.style.display = 'none';
            }
            if (avatar) {
                avatar.style.display = 'flex';
                avatar.style.border = '2px solid #ef4444';
            }
            // Add camera-off overlay
            const videoContainer = participantDiv.querySelector('.participant-video-container');
            if (videoContainer) {
                let overlay = participantDiv.querySelector('.camera-off-overlay');
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.className = 'camera-off-overlay';
                    overlay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.8); padding: 0.75rem 1.25rem; border-radius: 10px; color: #ef4444; font-weight: 600; z-index: 6; display: flex; align-items: center; gap: 0.5rem;';
                    overlay.innerHTML = '<i class="fas fa-video-slash"></i> <span>{% trans "Camera Off" %}</span>';
                    videoContainer.appendChild(overlay);
                }
                overlay.style.display = 'flex';
            }
        }
    }
    
    // Voice Activity Detection (VAD) - detects when user is speaking
    function setupVoiceActivityDetection(username, stream) {
        // Don't set up multiple analyzers for same user
        if (audioAnalyzers[username]) {
            return;
        }
        
        // Only set up VAD if stream has audio tracks
        if (!stream || !stream.getAudioTracks || stream.getAudioTracks().length === 0) {
            console.log(`No audio tracks for ${username}, skipping VAD`);
            return;
        }
        
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;
            
            const microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(analyser);
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            // Threshold for voice detection (adjust as needed)
            const SPEAKING_THRESHOLD = 25;
            let isSpeaking = false;
            
            function detectVoice() {
                // Check if user still exists
                const participantDiv = document.getElementById(`participant-${username}`);
                if (!participantDiv || (!peerConnections[username] && username !== '{{ user.username }}')) {
                    // Cleanup if user left
                    if (audioAnalyzers[username]) {
                        if (audioContext.state !== 'closed') {
                            audioContext.close();
                        }
                        delete audioAnalyzers[username];
                    }
                    return;
                }
                
                analyser.getByteFrequencyData(dataArray);
                
                // Calculate average volume (focus on speech frequencies: 300-3400 Hz)
                let sum = 0;
                let count = 0;
                for (let i = 0; i < bufferLength; i++) {
                    // Focus on mid-range frequencies (where speech is)
                    if (i > bufferLength * 0.1 && i < bufferLength * 0.7) {
                        sum += dataArray[i];
                        count++;
                    }
                }
                const average = count > 0 ? sum / count : 0;
                
                const wasSpeaking = isSpeaking;
                isSpeaking = average > SPEAKING_THRESHOLD;
                
                // Update visual indicator only when state changes
                if (isSpeaking !== wasSpeaking) {
                    updateSpeakingIndicator(username, isSpeaking);
                }
                
                // Continue monitoring
                requestAnimationFrame(detectVoice);
            }
            
            audioAnalyzers[username] = {
                audioContext: audioContext,
                analyser: analyser,
                stop: () => {
                    if (audioContext.state !== 'closed') {
                        audioContext.close();
                    }
                    delete audioAnalyzers[username];
                }
            };
            
            detectVoice();
            console.log(`Voice activity detection started for ${username}`);
        } catch (error) {
            console.error(`Error setting up VAD for ${username}:`, error);
        }
    }
    
    // Update speaking indicator (blue glow)
    function updateSpeakingIndicator(username, isSpeaking) {
        const participantDiv = document.getElementById(`participant-${username}`);
        if (!participantDiv) return;
        
        participantDiv.dataset.speaking = isSpeaking.toString();
        const indicator = participantDiv.querySelector('.speaking-indicator');
        
        if (indicator) {
            if (isSpeaking) {
                indicator.style.opacity = '1';
                indicator.style.borderColor = '#3b82f6';
                indicator.style.boxShadow = '0 0 20px rgba(59, 130, 246, 0.6), inset 0 0 20px rgba(59, 130, 246, 0.2)';
                participantDiv.style.borderColor = '#3b82f6';
                participantDiv.style.boxShadow = '0 0 25px rgba(59, 130, 246, 0.5)';
            } else {
                indicator.style.opacity = '0';
                indicator.style.borderColor = 'transparent';
                indicator.style.boxShadow = 'none';
                participantDiv.style.borderColor = 'transparent';
                participantDiv.style.boxShadow = 'none';
            }
        }
    }
    
    // Pin participant (show in large view)
    function pinParticipant(username) {
        const participantDiv = document.getElementById(`participant-${username}`);
        if (!participantDiv) return;
        
        const videoElement = participantDiv.querySelector('video');
        if (!videoElement || !videoElement.srcObject) {
            alert('{% trans "Cannot pin: user is not sharing video" %}');
            return;
        }
        
        pinnedParticipant = username;
        const pinnedView = document.getElementById('pinned-view');
        const pinnedVideo = document.getElementById('pinned-video');
        const pinnedUsername = document.getElementById('pinned-username');
        
        if (pinnedView && pinnedVideo) {
            // Show pinned view
            pinnedView.classList.remove('hidden');
            pinnedView.style.display = 'block';
            
            // Set video stream
            pinnedVideo.srcObject = videoElement.srcObject;
            pinnedVideo.play().catch(err => {
                console.error('Error playing pinned video:', err);
            });
            
            // Set username
            if (pinnedUsername) {
                pinnedUsername.textContent = username;
            }
            
            // Update pin button
            const pinBtn = participantDiv.querySelector('.pin-btn');
            if (pinBtn) {
                pinBtn.style.background = '#3b82f6';
                pinBtn.innerHTML = '<i class="fas fa-thumbtack"></i>';
            }
            
            console.log(`Pinned ${username}`);
        }
    }
    
    // Unpin participant
    function unpinParticipant() {
        if (!pinnedParticipant) return;
        
        const participantDiv = document.getElementById(`participant-${pinnedParticipant}`);
        if (participantDiv) {
            const pinBtn = participantDiv.querySelector('.pin-btn');
            if (pinBtn) {
                pinBtn.style.background = 'rgba(30, 41, 59, 0.9)';
            }
        }
        
        const pinnedView = document.getElementById('pinned-view');
        const pinnedVideo = document.getElementById('pinned-video');
        
        if (pinnedView) {
            pinnedView.classList.add('hidden');
            pinnedView.style.display = 'none';
        }
        
        if (pinnedVideo && pinnedVideo.srcObject) {
            pinnedVideo.srcObject = null;
        }
        
        pinnedParticipant = null;
        console.log('Unpinned participant');
    }
    
    function toggleScreenShare() {
        const container = document.getElementById('screen-share-container');
        const videoElement = document.getElementById('screen-share-video');
        const btn = document.getElementById('screen-share-btn');
        
        if (container.classList.contains('hidden')) {
            navigator.mediaDevices.getDisplayMedia({ 
                video: { 
                    cursor: 'always',
                    displaySurface: 'monitor'
                },
                audio: false 
            })
                .then(stream => {
                    screenShareStream = stream;
                    container.classList.remove('hidden');
                    container.style.display = 'block';
                    btn.style.background = '#3ba55c';
                    
                    if (videoElement) {
                        videoElement.srcObject = stream;
                        videoElement.play().catch(err => {
                            console.error('Error playing screen share:', err);
                        });
                    }
                    
                    // Stop screen share when track ends
                    stream.getVideoTracks()[0].onended = () => {
                        container.classList.add('hidden');
                        container.style.display = 'none';
                        btn.style.background = 'rgba(100, 116, 139, 0.6)';
                        if (videoElement && videoElement.srcObject) {
                            videoElement.srcObject.getTracks().forEach(track => track.stop());
                            videoElement.srcObject = null;
                        }
                        screenShareStream = null;
                    };
                })
                .catch(err => {
                    console.error("Screen share error:", err);
                    if (err.name !== 'NotAllowedError') {
                        alert("{% trans 'Could not start screen share. Please check permissions.' %}");
                    }
                });
        } else {
            // Stop screen share
            if (screenShareStream) {
                screenShareStream.getTracks().forEach(track => track.stop());
                screenShareStream = null;
            }
            if (videoElement && videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            container.classList.add('hidden');
            container.style.display = 'none';
            btn.style.background = 'rgba(100, 116, 139, 0.6)';
        }
    }
    
    function leaveVoiceChannel() {
        cleanupVoiceChannel();
        
        // Reset UI
        welcomeMessage.style.display = 'block';
        voiceStage.style.display = 'none';
        currentChannelSlug = null;
        currentChannelType = null;
        
        // Remove active state from channel
        document.querySelectorAll('.channel-item').forEach(item => {
            item.classList.remove('active');
        });
    }
    
    // Close/Disable Microphone
    function closeMicrophone() {
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = false; // Don't stop, just disable
            });
        }
        isMuted = true;
        
        // Update UI
        const btn = document.getElementById('mic-btn');
        if (btn) {
            btn.style.background = '#ef4444';
            const icon = btn.querySelector('i');
            if (icon) {
                icon.className = 'fas fa-microphone-slash';
            }
        }
        
        // Update local user's participant display
        updateParticipantMicState('{{ user.username }}', false);
        
        // Broadcast state change to all users in channel
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                signal_type: 'mic_state_change',
                data: {
                    username: '{{ user.username }}',
                    muted: true
                }
            }));
        }
        
        console.log('Microphone closed');
    }
    
    // Close/Disable Camera
    function closeCamera() {
        if (localStream) {
            localStream.getVideoTracks().forEach(track => {
                track.enabled = false; // Don't stop, just disable
            });
        }
        isVideoEnabled = false;
        
        // Update UI
        const btn = document.getElementById('video-btn');
        if (btn) {
            btn.style.background = '#ef4444';
            const icon = btn.querySelector('i');
            if (icon) {
                icon.className = 'fas fa-video-slash';
            }
        }
        
        // Hide video and show avatar again
        const participantDiv = document.getElementById('participant-{{ user.username }}');
        if (participantDiv) {
            const videoElement = participantDiv.querySelector('video');
            if (videoElement) {
                // Replace video with avatar
                const avatar = document.createElement('div');
                avatar.className = 'participant-avatar';
                avatar.style.cssText = 'width: 100px; height: 100px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; font-size: 2.5rem; color: white; font-weight: 700; margin-bottom: 1rem;';
                avatar.textContent = '{{ user.username }}'.charAt(0).toUpperCase();
                videoElement.replaceWith(avatar);
            }
        }
        
        // Update local user's participant display
        updateParticipantVideoState('{{ user.username }}', false);
        
        // Broadcast state change to all users in channel
        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            chatSocket.send(JSON.stringify({
                signal_type: 'camera_state_change',
                data: {
                    username: '{{ user.username }}',
                    enabled: false
                }
            }));
        }
        
        console.log('Camera closed');
    }
    
    // Close/Disable Headphones (Audio Output)
    function closeHeadphones() {
        // Stop all audio tracks from local stream
        if (localStream) {
            localStream.getAudioTracks().forEach(track => {
                track.stop();
            });
        }
        
        // Stop all remote audio streams
        Object.values(peerConnections).forEach(pc => {
            if (pc.getReceivers) {
                pc.getReceivers().forEach(receiver => {
                    if (receiver.track && receiver.track.kind === 'audio') {
                        receiver.track.stop();
                    }
                });
            }
        });
        
        // Mute all audio elements if any
        document.querySelectorAll('audio, video').forEach(element => {
            element.muted = true;
            element.pause();
        });
        
        console.log('Headphones/Audio output closed');
    }
    
    // Enable/Open Microphone
    async function openMicrophone() {
        try {
            if (!localStream) {
                // Need to create a new stream
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: true, 
                    video: isVideoEnabled 
                });
                addParticipantToGrid('{{ user.username }}', localStream, true);
            } else {
                // Get new audio track
                const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioTrack = audioStream.getAudioTracks()[0];
                
                // Replace audio track in existing stream
                localStream.addTrack(audioTrack);
                
                // Update peer connections with new track
                Object.values(peerConnections).forEach(pc => {
                    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');
                    if (sender) {
                        sender.replaceTrack(audioTrack);
                    }
                });
            }
            
            isMuted = false;
            
            // Update UI
            const btn = document.getElementById('mic-btn');
            if (btn) {
                btn.style.background = 'rgba(100, 116, 139, 0.6)';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-microphone';
                }
            }
            
            // Update local user's participant display
            updateParticipantMicState('{{ user.username }}', true);
            
            // Broadcast state change to all users in channel
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    signal_type: 'mic_state_change',
                    data: {
                        username: '{{ user.username }}',
                        muted: false
                    }
                }));
            }
            
            console.log('Microphone opened');
        } catch (error) {
            console.error('Error opening microphone:', error);
            alert('{% trans "Could not open microphone. Please check permissions." %}');
        }
    }
    
    // Enable/Open Camera
    async function openCamera() {
        try {
            if (!localStream) {
                // Need to create a new stream
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: isMuted ? false : true, 
                    video: true 
                });
                addParticipantToGrid('{{ user.username }}', localStream, true);
            } else {
                // Get new video track
                const videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                const videoTrack = videoStream.getVideoTracks()[0];
                
                // Remove old video tracks
                localStream.getVideoTracks().forEach(track => {
                    localStream.removeTrack(track);
                    track.stop();
                });
                
                // Add new video track to existing stream
                localStream.addTrack(videoTrack);
                
                // Update peer connections with new track
                Object.values(peerConnections).forEach(pc => {
                    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        sender.replaceTrack(videoTrack);
                    } else {
                        // If no video sender exists, add one
                        pc.addTrack(videoTrack, localStream);
                    }
                });
            }
            
            isVideoEnabled = true;
            
            // Update UI button
            const btn = document.getElementById('video-btn');
            if (btn) {
                btn.style.background = 'rgba(100, 116, 139, 0.6)';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-video';
                }
            }
            
            // Show video in participant display
            const participantDiv = document.getElementById('participant-{{ user.username }}');
            if (participantDiv && localStream.getVideoTracks().length > 0) {
                // Find avatar or video element
                let videoElement = participantDiv.querySelector('video');
                const avatar = participantDiv.querySelector('.participant-avatar');
                
                if (!videoElement && avatar) {
                    // Create video element to replace avatar
                    videoElement = document.createElement('video');
                    videoElement.autoplay = true;
                    videoElement.muted = true; // Mute own video
                    videoElement.style.cssText = 'width: 100%; height: 100%; max-width: 300px; max-height: 300px; object-fit: cover; border-radius: 15px; margin-bottom: 1rem;';
                    avatar.replaceWith(videoElement);
                }
                
                if (videoElement) {
                    videoElement.srcObject = localStream;
                }
            }
            
            // Update local user's participant display
            updateParticipantVideoState('{{ user.username }}', true);
            
            // Broadcast state change to all users in channel
            if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    signal_type: 'camera_state_change',
                    data: {
                        username: '{{ user.username }}',
                        enabled: true
                    }
                }));
            }
            
            console.log('Camera opened');
        } catch (error) {
            console.error('Error opening camera:', error);
            alert('{% trans "Could not open camera. Please check permissions." %}');
        }
    }
    
    // Enable/Open Headphones (Audio Output)
    function openHeadphones() {
        // Unmute all audio elements
        document.querySelectorAll('audio, video').forEach(element => {
            element.muted = false;
        });
        
        // Re-enable remote audio tracks
        Object.values(peerConnections).forEach(pc => {
            if (pc.getReceivers) {
                pc.getReceivers().forEach(receiver => {
                    if (receiver.track && receiver.track.kind === 'audio') {
                        receiver.track.enabled = true;
                    }
                });
            }
        });
        
        console.log('Headphones/Audio output opened');
    }
    
    // Use event delegation to prevent duplicate event listeners
    document.addEventListener('click', function(e) {
        // Microphone toggle
        if (e.target.closest('#mic-btn')) {
            const btn = e.target.closest('#mic-btn');
            e.preventDefault();
            
            if (isMuted) {
                // If muted, open microphone
                openMicrophone();
            } else {
                // If not muted, close microphone
                closeMicrophone();
            }
        }
        
        // Video toggle
        if (e.target.closest('#video-btn')) {
            const btn = e.target.closest('#video-btn');
            e.preventDefault();
            
            if (isVideoEnabled) {
                // If enabled, close camera
                closeCamera();
            } else {
                // If disabled, open camera
                openCamera();
            }
        }
        
        // Headphones toggle (if you add a button for it)
        if (e.target.closest('#headphone-btn')) {
            const btn = e.target.closest('#headphone-btn');
            e.preventDefault();
            
            // Toggle headphones state (you can add state tracking if needed)
            const isHeadphonesMuted = btn.dataset.muted === 'true';
            if (isHeadphonesMuted) {
                openHeadphones();
                btn.dataset.muted = 'false';
                btn.style.background = 'rgba(100, 116, 139, 0.6)';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-headphones';
                }
            } else {
                closeHeadphones();
                btn.dataset.muted = 'true';
                btn.style.background = '#ef4444';
                const icon = btn.querySelector('i');
                if (icon) {
                    icon.className = 'fas fa-headphones-alt';
                }
            }
        }
    });
    
    // Expose functions globally for external use
    window.closeMicrophone = closeMicrophone;
    window.closeCamera = closeCamera;
    window.closeHeadphones = closeHeadphones;
    window.openMicrophone = openMicrophone;
    window.openCamera = openCamera;
    window.openHeadphones = openHeadphones;
</script>
{% endblock %}
