{% extends 'base.html' %}
{% load i18n %}

{% block title %}{% trans "Game Room" %} - {{ game.game_id|truncatechars:8 }}{% endblock %}

{% block extra_css %}
    <style>
        /* ... (Tüm CSS stil kodunuz aynı, değişiklik yok) ... */
        :root {
            --p1-color: #d90429; --p2-color: #0077b6; --p3-color: #28a745; --p4-color: #ffc107;
            --board-bg: #212529; --cell-border: #495057; --cell-hover: #343a40;
        }
        #game-board-container { position: relative; width: 100%; max-width: 500px; margin: auto; }
        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--board-size, 5), 1fr);
            grid-template-rows: repeat(var(--board-size, 5), 1fr);
            width: 100%; aspect-ratio: 1 / 1; background-color: var(--board-bg);
            border: 2px solid var(--cell-border); border-radius: 8px; overflow: hidden;
        }
        .cell {
            border: 1px solid var(--cell-border); display: flex; align-items: center;
            justify-content: center; font-size: 1.8rem; color: white;
            transition: all 0.2s ease; cursor: pointer;
        }
        :root[style*="--board-size: 7"] .cell { font-size: 1.4rem; }
        :root[style*="--board-size: 6"] .cell { font-size: 1.6rem; }
        .cell:hover { background-color: var(--cell-hover); }
        .cell.p1 { background-color: var(--p1-color); box-shadow: 0 0 10px 2px var(--p1-color); }
        .cell.p2 { background-color: var(--p2-color); box-shadow: 0 0 10px 2px var(--p2-color); }
        .cell.p3 { background-color: var(--p3-color); box-shadow: 0 0 10px 2px var(--p3-color); }
        .cell.p4 { background-color: var(--p4-color); box-shadow: 0 0 10px 2px var(--p4-color); }
        .cell.explode-flash { 
            animation: explodeFlash 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            z-index: 15;
        }
        @keyframes explodeFlash {
            0% { 
                transform: scale(1) rotate(0deg); 
                opacity: 1; 
                box-shadow: 0 0 15px 8px currentColor, 0 0 30px 15px currentColor;
            }
            30% { 
                transform: scale(1.3) rotate(180deg); 
                opacity: 0.9; 
                box-shadow: 0 0 25px 15px currentColor, 0 0 50px 25px currentColor;
            }
            60% { 
                transform: scale(1.1) rotate(360deg); 
                opacity: 0.7; 
                box-shadow: 0 0 20px 12px currentColor;
            }
            100% { 
                transform: scale(1) rotate(360deg); 
                opacity: 1; 
                box-shadow: 0 0 10px 2px currentColor;
            }
        }
        /* Move highlight animation */
        .cell.move-highlight {
            animation: moveHighlight 0.8s ease-out forwards;
            z-index: 10;
        }
        @keyframes moveHighlight {
            0% { transform: scale(1); box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8); }
            50% { transform: scale(1.15); box-shadow: 0 0 30px 10px rgba(255, 255, 255, 1); }
            100% { transform: scale(1); box-shadow: 0 0 10px 2px currentColor; }
        }
        /* Player move indicator */
        .move-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 123, 255, 0.95), rgba(0, 86, 179, 0.95));
            color: white;
            padding: 1rem 2rem;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
            text-align: center;
            animation: moveIndicatorShow 0.4s ease-out;
        }
        .move-indicator.show {
            display: block;
        }
        @keyframes moveIndicatorShow {
            0% { transform: translateX(-50%) translateY(-100%); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        .particle {
            position: absolute; 
            width: 20px; 
            height: 20px; 
            border-radius: 3px; 
            z-index: 99;
            transform: translate(-50%, -50%) scale(1); 
            opacity: 1; 
            background: linear-gradient(135deg, currentColor, rgba(255, 255, 255, 0.3));
            box-shadow: 0 0 10px currentColor, 0 0 20px currentColor, inset 0 0 5px rgba(255, 255, 255, 0.5); 
            font-size: 12px; 
            display: flex;
            align-items: center; 
            justify-content: center; 
            overflow: hidden; 
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .particle.up    { animation: particleUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
        .particle.down  { animation: particleDown 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
        .particle.left  { animation: particleLeft 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
        .particle.right { animation: particleRight 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
        @keyframes particleUp { 
            0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; } 
            50% { transform: translate(-50%, -250%) scale(1.2) rotate(180deg); opacity: 0.9; } 
            100% { transform: translate(-50%, -500%) scale(0.2) rotate(360deg); opacity: 0; } 
        }
        @keyframes particleDown { 
            0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; } 
            50% { transform: translate(-50%, 250%) scale(1.2) rotate(-180deg); opacity: 0.9; } 
            100% { transform: translate(-50%, 500%) scale(0.2) rotate(-360deg); opacity: 0; } 
        }
        @keyframes particleLeft { 
            0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; } 
            50% { transform: translate(-250%, -50%) scale(1.2) rotate(180deg); opacity: 0.9; } 
            100% { transform: translate(-500%, -50%) scale(0.2) rotate(360deg); opacity: 0; } 
        }
        @keyframes particleRight { 
            0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; } 
            50% { transform: translate(250%, -50%) scale(1.2) rotate(-180deg); opacity: 0.9; } 
            100% { transform: translate(500%, -50%) scale(0.2) rotate(-360deg); opacity: 0; } 
        }
        #wheel-overlay, #game-over-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.9);
            color: #fff; display: none; flex-direction: column; align-items: center;
            justify-content: center; z-index: 20; border-radius: 8px; text-align: center;
        }
        #wheel-spinner { font-size: 100px; margin-bottom: 20px; animation: spin 1.5s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #message-log { height: 250px; overflow-y: scroll; background: #343a40; border-radius: 0.25rem; border: 1px solid #495057; color: #f8f9fa; }
        #message-log p { margin: 0; padding: 2px 8px; }
        .player-box {
            padding: 0.75rem 1rem; border-radius: 8px; border: 2px solid transparent;
            transition: all 0.3s ease-in-out; margin-bottom: 0.5rem;
            /* YENİ: Kick butonu için */
            display: flex; justify-content: space-between; align-items: center;
        }
        .player-box.p1 { background-color: rgba(217, 4, 41, 0.1); }
        .player-box.p2 { background-color: rgba(0, 119, 182, 0.1); }
        .player-box.p3 { background-color: rgba(40, 167, 69, 0.1); }
        .player-box.p4 { background-color: rgba(255, 193, 7, 0.1); }
        .player-box.active-turn { border-color: var(--p1-color); box-shadow: 0 0 15px 3px var(--p1-color); transform: scale(1.03); }
        .player-box.active-turn.p1 { border-color: var(--p1-color); box-shadow: 0 0 15px 3px var(--p1-color); }
        .player-box.active-turn.p2 { border-color: var(--p2-color); box-shadow: 0 0 15px 3px var(--p2-color); }
        .player-box.active-turn.p3 { border-color: var(--p3-color); box-shadow: 0 0 15px 3px var(--p3-color); }
        .player-box.active-turn.p4 { border-color: var(--p4-color); box-shadow: 0 0 15px 3px var(--p4-color); }

        /* YENİ: Kick Butonu Stili */
        .kick-btn {
            background-color: #dc3545; color: white; border: none;
            border-radius: 5px; padding: 2px 8px; font-size: 0.8rem;
            cursor: pointer; opacity: 0.7;
        }
        .kick-btn:hover { opacity: 1; }
        
        /* YENİ: Elenmiş Oyuncu Stili */
        .player-box.eliminated {
            opacity: 0.6;
            background-color: rgba(108, 117, 125, 0.3) !important;
            position: relative;
        }
        .player-box.winner {
            background-color: rgba(40, 167, 69, 0.2) !important;
            border: 2px solid #28a745 !important;
        }
        .player-box.eliminated::after {
            content: '❌ ELIMINATED';
            position: absolute;
            right: 10px;
            color: #dc3545;
            font-weight: bold;
            font-size: 0.85rem;
            animation: eliminationPulse 0.6s ease-in-out;
        }
        @keyframes eliminationPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }
        
        /* YENİ: Elenme Bildirimi Overlay */
        #elimination-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(220, 53, 69, 0.95), rgba(139, 0, 0, 0.95));
            color: white;
            padding: 2rem 3rem;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            text-align: center;
            animation: eliminationShow 0.5s ease-out;
        }
        #elimination-overlay.show {
            display: block;
        }
        @keyframes eliminationShow {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.15); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        @keyframes eliminationHide {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        }
        #elimination-overlay h3 {
            font-size: 2rem;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #elimination-overlay .eliminated-name {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0.5rem 0;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }
    </style>
{% endblock %}


{% block content %}
    <h1 class="mb-4">{% trans "Game Room" %}</h1>
    <div class="row">
        <div class="col-lg-7 col-md-8 mb-4">
            <div id="game-board-container">
                <div id="game-over-overlay">
                    <h2 class="mb-3">{% trans "Game Over!" %}</h2>
                    <h4 class="mb-4">{% trans "Winner:" %} <span id="winner-name">...</span></h4>
                    <a href="{% url 'game_specific_lobby' game_slug=game.game_type.slug %}" class="btn btn-primary btn-lg">{% trans "New Game" %}</a>
                </div>
                <div id="wheel-overlay">
                    <div id="wheel-spinner"><i class="fas fa-compact-disc"></i></div>
                    <h4>{% trans "Determining starting order..." %}</h4>
                    <h3 id="wheel-winner-name" class="mt-3" style="display: none;"></h3>
                </div>
                <div id="game-board">
                    </div>
            </div>
        </div>
        
        <!-- Move Indicator -->
        <div id="move-indicator" class="move-indicator">
            <strong id="move-indicator-text"></strong>
        </div>
        
        <!-- YENİ: Elenme Bildirimi Overlay -->
        <div id="elimination-overlay">
            <h3><i class="fas fa-skull"></i> {% trans "PLAYER ELIMINATED" %}</h3>
            <div id="eliminated-players-list"></div>
        </div>

        <div class="col-lg-5 col-md-4">
            <div class="card shadow-sm text-bg-dark border-secondary">
                <div class="card-header fs-5 border-secondary">
                    {% trans "Game Information" %}
                </div>
                <div class="card-body">
                    <h5 id="turn-indicator" class="card-title mb-3">
                        {% trans "Turn:" %} {{ game.current_turn.username|default:_("Waiting for players...") }}
                    </h5>

                    <div id="player-list-container">
                        </div>

                    <div class="alert alert-info mt-3" id="waiting-alert" style="display: none;">
                        <i class="fas fa-spinner fa-spin me-1"></i>
                        {% trans "Waiting for players..." %} (<span id="player-count-span">1</span>/<span id="max-player-span">{{ game.game_type.max_players }}</span>)
                    </div>

                    {% if is_spectator %}
                    <div class="alert alert-dark border-warning text-warning mt-3" role="alert">
                        <strong>{% trans "You are in spectator mode." %}</strong> {% trans "You cannot make moves." %}
                    </div>
                    {% endif %}

                    <hr class="border-secondary">

                    {% if game.host == request.user and game.status == 'waiting' %}
                    <div id="host-controls">
                        <button id="start-game-btn" class="btn btn-success w-100" disabled>
                            <i class="fas fa-play me-1"></i> {% trans "Start Game" %}
                        </button>
                        <small id="start-game-helper" class="form-text text-muted d-block mt-1">
                            {% trans "At least" %} {{ game.game_type.min_players }} {% trans "players required to start." %}
                        </small>
                    </div>
                    {% endif %}

                    <label for="message-log" class="form-label mt-3">{% trans "Game Log:" %}</label>
                    <div id="message-log" class="p-2"></div>
                    <a href="{% url 'game_specific_lobby' game_slug=game.game_type.slug %}" class="btn btn-secondary mt-3 w-100">{% trans "Leave Lobby" %}</a>
                </div>
            </div>
        </div>
    </div>

    {{ game_id_json|json_script:"game-id" }}
    {{ username_json|json_script:"current-username" }}
    {{ is_spectator|json_script:"is-spectator" }}
    {{ initial_board_state_json|json_script:"initial-board-state" }}
    {{ board_size_json|json_script:"board-size-json" }}

    {{ game.host.username|json_script:"host-username" }}
    {{ game.game_type.min_players|json_script:"min-players" }}
    {{ eliminated_players_json|json_script:"eliminated-players-json" }}
    {% if game.winner %}{{ game.winner.username|json_script:"winner-json" }}{% endif %}
{% endblock %}

{% block extra_js %}
    <script>
        // DOM elementleri ve veriler
        const gameId = JSON.parse(document.getElementById('game-id').textContent);
        const myUsername = JSON.parse(document.getElementById('current-username').textContent);
        const isSpectator = JSON.parse(document.getElementById('is-spectator').textContent);
        const initialBoardState = JSON.parse(document.getElementById('initial-board-state').textContent);
        let boardSize = JSON.parse(document.getElementById('board-size-json').textContent);
        document.documentElement.style.setProperty('--board-size', boardSize);

        // YENİ: Host kontrol verileri
        const hostUsername = JSON.parse(document.getElementById('host-username').textContent);
        const minPlayers = JSON.parse(document.getElementById('min-players').textContent);
        const amIHost = (myUsername === hostUsername);
        let eliminatedPlayers = JSON.parse(document.getElementById('eliminated-players-json').textContent || '[]');
        const winnerUsername = document.getElementById('winner-json') ? JSON.parse(document.getElementById('winner-json').textContent) : null;

        const boardElement = document.getElementById('game-board');
        const turnIndicator = document.getElementById('turn-indicator');
        const messageLog = document.getElementById('message-log');
        const playerListContainer = document.getElementById('player-list-container');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const winnerNameEl = document.getElementById('winner-name');
        const wheelOverlay = document.getElementById('wheel-overlay');
        const wheelWinnerText = document.getElementById('wheel-winner-name');

        // YENİ: Lobi UI elementleri
        const waitingAlert = document.getElementById('waiting-alert');
        const playerCountSpan = document.getElementById('player-count-span');
        const hostControls = document.getElementById('host-controls');
        const startGameBtn = document.getElementById('start-game-btn');
        const startGameHelper = document.getElementById('start-game-helper');

        let playerColors = {};
        let playerUsernames = [];
        // Track eliminated players that have already been shown (to avoid duplicate messages)
        let shownEliminatedPlayers = new Set(eliminatedPlayers || []);
        
        // Enhanced dice icons with better visual representation
        const diceIcons = { 
            1: 'fa-dice-one', 
            2: 'fa-dice-two', 
            3: 'fa-dice-three',
            4: 'fa-dice-four',
            5: 'fa-dice-five',
            6: 'fa-dice-six'
        };
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        // WebSocket Bağlantısı
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const gameSocket = new WebSocket(
            wsProtocol + window.location.host + '/ws/dice-wars/' + gameId + '/'
        );

        // Translation strings (will be replaced by Django i18n in production)
        const translations = {
            'waiting': '{% trans "Waiting for players..." %}',
            'turn': '{% trans "Turn:" %}',
            'gameOver': '{% trans "Game Over!" %}',
            'winner': '{% trans "Winner:" %}',
            'eliminated': '{% trans "eliminated" %}',
            'madeMove': '{% trans "made a move" %}',
            'youEliminated': '{% trans "You were eliminated! You can no longer make moves, but you can continue watching the game." %}',
            'spectatorNoMove': '{% trans "Spectators cannot make moves." %}',
            'eliminatedNoMove': '{% trans "Eliminated players cannot make moves." %}',
            'connectionLost': '{% trans "Connection to server lost. Please refresh the page." %}',
            'connected': '{% trans "Successfully connected to game table." %}',
            'kicked': '{% trans "You were kicked from the game by the host." %}',
            'gameReady': '{% trans "Game is ready to start!" %}',
            'playersRequired': '{% trans "At least" %}',
            'playersRequiredEnd': '{% trans "players required to start." %}',
            'startGameConfirm': '{% trans "Are you sure you want to start the game? No new players will be accepted." %}',
            'kickPlayerConfirm': '{% trans "Are you sure you want to kick" %}',
            'kickPlayerConfirmEnd': '{% trans "from the game?" %}',
            'startingOrder': '{% trans "Determining starting order..." %}',
            'starts': '{% trans "starts!" %}'
        };

        // Sunucudan Mesaj Alma (IMPROVED ANIMATION SEQUENCING)
        gameSocket.onmessage = async function(e) {
            const data = JSON.parse(e.data);
            console.log("Received from server:", data);

            if (data.type === 'error') {
                logMessage(data.message, 'danger');
                return;
            }

            if (data.type === 'game_state') {
                // 1. Update player info first
                if (data.players) {
                    playerUsernames = data.players;
                    if (data.eliminated_players !== undefined) {
                        eliminatedPlayers = data.eliminated_players;
                        // Update shown eliminated players set
                        data.eliminated_players.forEach(p => shownEliminatedPlayers.add(p));
                    }
                    updatePlayerList(data.players, eliminatedPlayers, data.winner);

                    if (data.status === 'waiting' && !data.players.includes(myUsername) && !isSpectator) {
                        alert(translations.kicked);
                        const lobbyUrl = "{% url 'game_specific_lobby' game_slug=game.game_type.slug %}";
                        window.location.href = lobbyUrl;
                        return;
                    }
                }

                // 2. Update board size
                if (data.board_size && data.board_size !== boardSize) {
                    boardSize = data.board_size;
                    document.documentElement.style.setProperty('--board-size', boardSize);
                }

                // 3. Show move indicator if message contains move info
                if (data.message) {
                    // Check for move messages in different languages
                    const movePatterns = ['made a move', 'tıkladı', 'made a move'];
                    const hasMove = movePatterns.some(pattern => data.message.toLowerCase().includes(pattern.toLowerCase()));
                    if (hasMove) {
                        // Extract username (usually first word before the move text)
                        const parts = data.message.split(' ');
                        if (parts.length > 0) {
                            showMoveIndicator(parts[0]);
                        }
                    }
                }

                // 4. Update turn indicator
                updateTurnIndicator(data.turn, data.status, data.winner);

                // 5. Game start wheel
                if (data.special_event === 'game_start_roll') {
                    wheelWinnerText.style.display = 'none';
                    wheelOverlay.classList.remove('finished');
                    wheelOverlay.style.display = 'flex';
                    await sleep(2000);
                    wheelWinnerText.innerHTML = `<i class="fas fa-check-circle"></i> ${data.turn} ${translations.starts}`;
                    wheelWinnerText.style.display = 'block';
                    wheelOverlay.classList.add('finished');
                    await sleep(1500);
                    wheelOverlay.style.display = 'none';
                    logMessage(data.message, 'success');
                }

                // 6. IMPROVED: Proper animation sequencing
                // IMPORTANT: Show animations on CURRENT board BEFORE rendering new state
                
                // First, show move animation on the moved cell (for all players) - BEFORE rendering new board
                if (data.move_cell && data.move_cell.length === 2) {
                    const [moveRow, moveCol] = data.move_cell;
                    // Find cell on CURRENT board (before render)
                    const moveCell = boardElement.querySelector(`.cell[data-row="${moveRow}"][data-col="${moveCol}"]`);
                    if (moveCell) {
                        moveCell.classList.add('move-highlight');
                        setTimeout(() => {
                            moveCell.classList.remove('move-highlight');
                        }, 800);
                    }
                    // Small delay to see the move animation
                    await sleep(150);
                }
                
                // IMPORTANT: Show explosions on CURRENT board BEFORE rendering new state
                // This ensures explosions are visible on the cells that are about to be cleared
                if (data.exploded_cells && data.exploded_cells.length > 0) {
                    // Show explosions on current board state
                    await triggerSequentialExplosions(data.exploded_cells);
                    // Small delay after explosions
                    await sleep(100);
                }
                
                // Then, render board with new state (this updates the board for all players)
                // This happens AFTER animations so animations are visible on the old board
                if (data.state) {
                    renderBoard(data.state);
                    // Small delay to see the updated board
                    await sleep(50);
                }

                // After explosions, handle eliminations (only NEW ones - avoid duplicate messages)
                if (data.eliminated_players !== undefined && data.eliminated_players.length > 0) {
                    // Check which players are newly eliminated (not shown before)
                    const newlyEliminated = data.eliminated_players.filter(p => !shownEliminatedPlayers.has(p));
                    
                    // Update our tracking
                    eliminatedPlayers = data.eliminated_players;
                    newlyEliminated.forEach(p => shownEliminatedPlayers.add(p));
                    
                    // Only show animation for newly eliminated players
                    if (newlyEliminated.length > 0) {
                        await sleep(150); // Small gap after explosions
                        await handlePlayerElimination(newlyEliminated);
                    }
                } else if (data.eliminated_players !== undefined) {
                    // Update tracking even if empty array
                    eliminatedPlayers = data.eliminated_players || [];
                }

                // Finally, log message if not game start
                if (data.message && data.special_event !== 'game_start_roll') {
                    logMessage(data.message, 'info');
                }
            }
        };

        gameSocket.onclose = function(e) {
            logMessage(translations.connectionLost, 'danger');
        };

        gameSocket.onopen = function(e) {
            logMessage(translations.connected, 'success');
            // Sayfa yüklendiğinde gelen oyuncu listesini ve renkleri ayarla
            const initialPlayers = [{% for p in game.players.all %}"{{ p.username }}"{% if not forloop.last %}, {% endif %}{% endfor %}];
            updatePlayerList(initialPlayers, eliminatedPlayers, winnerUsername);
            // Sayfa yüklendiğinde durumu da güncelle (Örn. oyun bitmişse)
            updateTurnIndicator("{{ game.current_turn.username|default:'' }}", "{{ game.status }}", "{{ game.winner.username|default:'' }}");
        };

        // --- DEĞİŞTİ: Oyuncu Listesi Güncelleme (Kick, Elenme ve Kazanma durumu eklendi) ---
        function updatePlayerList(players, eliminated = [], winner = null) {
            playerListContainer.innerHTML = '';
            playerColors = {};

            // Oyuncu sayacı (Lobi için)
            if (playerCountSpan) playerCountSpan.textContent = players.length;

            players.forEach((username, index) => {
                const playerClass = `p${index + 1}`;
                playerColors[username] = playerClass;

                const playerBox = document.createElement('div');
                playerBox.className = `player-box ${playerClass}`;
                playerBox.id = `player-box-${username}`;
                
                // Elenmiş oyuncu kontrolü
                const isEliminated = eliminated.includes(username);
                if (isEliminated) {
                    playerBox.classList.add('eliminated');
                }
                
                // Kazanan/Kaybeden durumu
                let statusBadge = '';
                if (winner) {
                    if (username === winner) {
                        statusBadge = `<span class="badge bg-success ms-1"><i class="fas fa-trophy"></i> {% trans "Won" %}</span>`;
                        playerBox.classList.add('winner');
                    } else if (eliminated.includes(username)) {
                        statusBadge = `<span class="badge bg-danger ms-1"><i class="fas fa-skull"></i> {% trans "Eliminated" %}</span>`;
                    } else {
                        statusBadge = `<span class="badge bg-secondary ms-1">{% trans "Lost" %}</span>`;
                    }
                } else if (isEliminated) {
                    statusBadge = `<span class="badge bg-danger ms-1"><i class="fas fa-skull"></i> {% trans "Eliminated" %}</span>`;
                }

                let badges = '';
                if (username === hostUsername) {
                    badges += `<span class="badge bg-warning">{% trans "Host" %}</span>`;
                }
                if (username === myUsername) {
                    badges += `<span class="badge bg-primary ms-1">{% trans "You" %}</span>`;
                }
                badges += statusBadge;

                // --- YENİ: Kick Butonu HTML (sadece beklemede ve elenmemiş oyuncular için) ---
                let kickButtonHtml = '';
                if (amIHost && username !== myUsername && !isEliminated && !winner) {
                    kickButtonHtml = `
                        <button class="kick-btn" data-username="${username}" title="{% trans 'Kick Player' %}">
                            <i class="fas fa-times"></i>
                        </button>`;
                }

                playerBox.innerHTML = `
                    <div class="d-flex align-items-center">
                        <strong>
                            <i class="fas fa-circle" style="color: var(--${playerClass}-color);"></i>
                            ${username}
                        </strong>
                        <div class="ms-2">${badges}</div>
                    </div>
                    ${kickButtonHtml}
                `;
                playerListContainer.appendChild(playerBox);
            });

            // --- YENİ: Başlat Butonu Kontrolü ---
            if (amIHost && startGameBtn) {
                if (players.length >= minPlayers) {
                    startGameBtn.disabled = false;
                    startGameHelper.textContent = translations.gameReady;
                    startGameHelper.classList.remove('text-muted');
                    startGameHelper.classList.add('text-success');
                } else {
                    startGameBtn.disabled = true;
                    startGameHelper.textContent = `${translations.playersRequired} ${minPlayers} ${translations.playersRequiredEnd}`;
                    startGameHelper.classList.add('text-muted');
                    startGameHelper.classList.remove('text-success');
                }
            }
        }

        // Show move indicator
        function showMoveIndicator(username) {
            const moveIndicator = document.getElementById('move-indicator');
            const moveIndicatorText = document.getElementById('move-indicator-text');
            if (moveIndicator && moveIndicatorText) {
                moveIndicatorText.textContent = `${username} ${translations.madeMove}`;
                moveIndicator.classList.add('show');
                setTimeout(() => {
                    moveIndicator.classList.remove('show');
                }, 1500);
            }
        }

        // --- IMPROVED: Turn Indicator Update ---
        function updateTurnIndicator(turnUsername, status, winnerUsername) {
            document.querySelectorAll('.player-box').forEach(box => {
                box.classList.remove('active-turn');
            });

            if (status === 'finished') {
                turnIndicator.textContent = translations.gameOver;
                logMessage(translations.winner + " " + winnerUsername, 'success');
                winnerNameEl.textContent = winnerUsername;
                gameOverOverlay.style.display = 'flex';
                if (waitingAlert) waitingAlert.style.display = 'none';
                if (hostControls) hostControls.style.display = 'none';

            } else if (status === 'waiting') {
                turnIndicator.textContent = translations.waiting;
                if (waitingAlert) waitingAlert.style.display = 'block';
                if (hostControls) hostControls.style.display = 'block';

            } else if (status === 'in_progress' && turnUsername) {
                turnIndicator.textContent = translations.turn + " " + turnUsername;
                if (waitingAlert) waitingAlert.style.display = 'none';
                if (hostControls) hostControls.style.display = 'none';

                const activePlayerBox = document.getElementById(`player-box-${turnUsername}`);
                if (activePlayerBox) {
                    activePlayerBox.classList.add('active-turn');
                }
            }
        }

        // IMPROVED: Sequential explosions with better timing and visual effects
        // This function shows explosions on the CURRENT board state (before it's updated)
        async function triggerSequentialExplosions(explodedCells) {
            const EXPLOSION_DELAY = 80; // Much faster explosions
            for (const coords of explodedCells) {
                const [r, c] = coords;
                // Find cell on CURRENT board (before new state is rendered)
                const cellEl = boardElement.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                if (cellEl) {
                    // Get player color from current cell classes
                    const playerClass = Array.from(cellEl.classList).find(cls => cls.startsWith('p'));
                    const color = playerClass ? `var(--${playerClass}-color)` : 'var(--cell-border)';
                    createExplosion(cellEl, color);
                    await sleep(EXPLOSION_DELAY);
                }
            }
            await sleep(150); // Shorter wait after all explosions
        }
        function renderBoard(boardState) {
            boardElement.innerHTML = '';
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('cell');
                    cellElement.dataset.row = r;
                    cellElement.dataset.col = c;
                    const rowData = boardState[String(r)];
                    const cellData = rowData ? rowData[String(c)] : null;
                    if (cellData && cellData.count > 0) {
                        // Enhanced dice design with better styling
                        const diceContainer = document.createElement('div');
                        diceContainer.style.cssText = 'display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; position: relative;';
                        
                        if (diceIcons[cellData.count]) {
                            const icon = document.createElement('i');
                            icon.className = `fas ${diceIcons[cellData.count]}`;
                            icon.style.cssText = 'font-size: 1.5em; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); text-shadow: 0 1px 2px rgba(0,0,0,0.8);';
                            diceContainer.appendChild(icon);
                        } else {
                            const countText = document.createElement('span');
                            countText.textContent = cellData.count;
                            countText.style.cssText = 'font-weight: bold; font-size: 1.3em; text-shadow: 0 2px 4px rgba(0,0,0,0.8);';
                            diceContainer.appendChild(countText);
                        }
                        cellElement.appendChild(diceContainer);
                        
                        const playerClass = playerColors[cellData.owner];
                        if (playerClass) {
                            cellElement.classList.add(playerClass);
                        }
                    } else {
                        cellElement.innerHTML = '';
                    }
                    boardElement.appendChild(cellElement);
                }
            }
        }

        // IMPROVED: Move handling with immediate visual feedback (local only, server will broadcast to all)
        boardElement.addEventListener('click', function(e) {
            const cell = e.target.closest('.cell');
            if (!cell) return;
            if (isSpectator) {
                logMessage(translations.spectatorNoMove, 'warning');
                return;
            }
            if (!playerUsernames.includes(myUsername)) {
                logMessage(translations.eliminatedNoMove, 'warning');
                return;
            }
            if (gameOverOverlay.style.display === 'flex' || wheelOverlay.style.display === 'flex') {
                return;
            }
            if (turnIndicator.textContent.startsWith(translations.turn)) {
                const row = cell.dataset.row;
                const col = cell.dataset.col;
                
                // Immediate local visual feedback (server will broadcast to all players)
                cell.classList.add('move-highlight');
                setTimeout(() => {
                    cell.classList.remove('move-highlight');
                }, 800);
                
                gameSocket.send(JSON.stringify({
                    'type': 'make_move',
                    'row': parseInt(row),
                    'col': parseInt(col)
                }));
            }
        });

        // Start Game Button Listener
        if (startGameBtn) {
            startGameBtn.addEventListener('click', function() {
                if (confirm(translations.startGameConfirm)) {
                    gameSocket.send(JSON.stringify({
                        'type': 'start_game'
                    }));
                }
            });
        }

        // Kick Button Listener
        playerListContainer.addEventListener('click', function(e) {
            const kickBtn = e.target.closest('.kick-btn');
            if (kickBtn) {
                const usernameToKick = kickBtn.dataset.username;
                if (confirm(`${translations.kickPlayerConfirm} ${usernameToKick} ${translations.kickPlayerConfirmEnd}`)) {
                    gameSocket.send(JSON.stringify({
                        'type': 'kick_player',
                        'username_to_kick': usernameToKick
                    }));
                }
            }
        });


        // IMPROVED: Faster elimination animation
        async function handlePlayerElimination(eliminatedUsernames) {
            const eliminationOverlay = document.getElementById('elimination-overlay');
            const eliminatedPlayersList = document.getElementById('eliminated-players-list');
            
            if (!eliminationOverlay || !eliminatedPlayersList) return;
            
            // Mark eliminated players in list immediately
            eliminatedUsernames.forEach(username => {
                const playerBox = document.getElementById(`player-box-${username}`);
                if (playerBox) {
                    playerBox.classList.add('eliminated');
                    playerBox.style.animation = 'eliminationPulse 0.6s ease-in-out';
                }
            });
            
            // Show eliminated players in overlay
            eliminatedPlayersList.innerHTML = '';
            eliminatedUsernames.forEach((username, index) => {
                const eliminatedDiv = document.createElement('div');
                eliminatedDiv.className = 'eliminated-name';
                eliminatedDiv.textContent = `❌ ${username}`;
                eliminatedDiv.style.animationDelay = `${index * 0.1}s`;
                eliminatedPlayersList.appendChild(eliminatedDiv);
            });
            
            // Show overlay
            eliminationOverlay.classList.add('show');
            
            // Faster: Hide after 1 second instead of 2.5
            await sleep(1000);
            eliminationOverlay.style.animation = 'eliminationHide 0.3s ease-out forwards';
            await sleep(300);
            eliminationOverlay.classList.remove('show');
            eliminationOverlay.style.animation = '';
            
            // Inform user if eliminated
            if (eliminatedUsernames.includes(myUsername)) {
                logMessage(translations.youEliminated, 'warning');
            }
        }

        // ... (logMessage ve createExplosion aynı) ...
        function logMessage(msg, type = 'info') {
            if (!msg) return; // Boş mesajları loglama
            let textClass = 'text-info';
            if (type === 'danger') { textClass = 'text-danger'; }
            else if (type === 'success') { textClass = 'text-success'; }
            else if (type === 'warning') { textClass = 'text-warning'; }
            const p = document.createElement('p');
            p.classList.add('m-0', 'small', textClass);
            p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            messageLog.appendChild(p);
            messageLog.scrollTop = messageLog.scrollHeight;
        }
        function createExplosion(cellEl, color) {
            const gameBoardContainer = document.getElementById('game-board-container');
            const rect = cellEl.getBoundingClientRect();
            const containerRect = gameBoardContainer.getBoundingClientRect();
            const startTop = rect.top - containerRect.top + (rect.height / 2);
            const startLeft = rect.left - containerRect.left + (rect.width / 2);
            const directions = ['up', 'down', 'left', 'right'];
            
            // Enhanced explosion flash
            cellEl.style.setProperty('color', color);
            cellEl.classList.add('explode-flash');
            setTimeout(() => {
                cellEl.classList.remove('explode-flash');
                cellEl.style.removeProperty('color');
            }, 400);
            
            // Create more dramatic dice particles
            const diceCount = 8; // More particles for better effect
            for (let i = 0; i < diceCount; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                
                // Random dice icon
                const diceValues = [1, 2, 3, 4, 5, 6];
                const randomDice = diceValues[Math.floor(Math.random() * diceValues.length)];
                const icon = document.createElement('i');
                icon.className = `fas ${diceIcons[randomDice] || 'fa-dice'}`;
                icon.style.cssText = 'font-size: 0.8em;';
                particle.appendChild(icon);
                
                particle.style.color = color;
                particle.style.top = `${startTop}px`;
                particle.style.left = `${startLeft}px`;
                
                // Distribute particles in all directions
                const dir = directions[i % directions.length];
                
                gameBoardContainer.appendChild(particle);
                void particle.offsetWidth;
                
                // Use existing particle animations
                particle.classList.add(dir);
                
                setTimeout(() => {
                    if (particle.parentElement) {
                        particle.parentElement.removeChild(particle);
                    }
                }, 500);
            }
        }

        // İlk render
        console.log(`İlk tahta ${boardSize}x${boardSize} olarak çiziliyor...`, initialBoardState);
        renderBoard(initialBoardState);

    </script>
{% endblock %}