{% extends 'base.html' %}

{% block title %}Oyun Odası - {{ game.game_id|truncatechars:8 }}{% endblock %}

{% block extra_css %}
    <style>
        :root {
            /* 4 oyuncuya kadar renk tanımlaması */
            --p1-color: #d90429; /* Kırmızı */
            --p2-color: #0077b6; /* Mavi */
            --p3-color: #28a745; /* Yeşil */
            --p4-color: #ffc107; /* Sarı */

            --board-bg: #212529;
            --cell-border: #495057;
            --cell-hover: #343a40;
        }

        #game-board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: auto;
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--board-size, 5), 1fr);
            grid-template-rows: repeat(var(--board-size, 5), 1fr);
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: var(--board-bg);
            border: 2px solid var(--cell-border);
            border-radius: 8px;
            overflow: hidden;
        }

        .cell {
            border: 1px solid var(--cell-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: white;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        :root[style*="--board-size: 7"] .cell { font-size: 1.4rem; }
        :root[style*="--board-size: 6"] .cell { font-size: 1.6rem; }
        .cell:hover { background-color: var(--cell-hover); }
        .cell.p1 { background-color: var(--p1-color); box-shadow: 0 0 10px 2px var(--p1-color); }
        .cell.p2 { background-color: var(--p2-color); box-shadow: 0 0 10px 2px var(--p2-color); }
        .cell.p3 { background-color: var(--p3-color); box-shadow: 0 0 10px 2px var(--p3-color); }
        .cell.p4 { background-color: var(--p4-color); box-shadow: 0 0 10px 2px var(--p4-color); }
        .cell.explode-flash {
            animation: explodeFlash 0.3s ease-out forwards;
        }
        @keyframes explodeFlash {
            0% { transform: scale(1); opacity: 1; box-shadow: 0 0 10px 5px currentColor; }
            50% { transform: scale(1.1); opacity: 0.8; box-shadow: 0 0 20px 10px currentColor; }
            100% { transform: scale(1); opacity: 1; box-shadow: 0 0 10px 5px currentColor; }
        }
        .particle {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            z-index: 99;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            background-color: currentColor;
            box-shadow: 0 0 5px currentColor;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            color: white;
        }
        .particle.up    { animation: particleUp 0.6s ease-out forwards; }
        .particle.down  { animation: particleDown 0.6s ease-out forwards; }
        .particle.left  { animation: particleLeft 0.6s ease-out forwards; }
        .particle.right { animation: particleRight 0.6s ease-out forwards; }
        @keyframes particleUp {
            0%   { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50%  { transform: translate(-50%, -200%) scale(0.8) rotate(90deg); opacity: 0.8; }
            100% { transform: translate(-50%, -450%) scale(0.3) rotate(180deg); opacity: 0; }
        }
        @keyframes particleDown {
            0%   { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50%  { transform: translate(-50%, 200%) scale(0.8) rotate(-90deg); opacity: 0.8; }
            100% { transform: translate(-50%, 450%) scale(0.3) rotate(-180deg); opacity: 0; }
        }
        @keyframes particleLeft {
            0%   { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50%  { transform: translate(-200%, -50%) scale(0.8) rotate(90deg); opacity: 0.8; }
            100% { transform: translate(-450%, -50%) scale(0.3) rotate(180deg); opacity: 0; }
        }
        @keyframes particleRight {
            0%   { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50%  { transform: translate(200%, -50%) scale(0.8) rotate(-90deg); opacity: 0.8; }
            100% { transform: translate(450%, -50%) scale(0.3) rotate(180deg); opacity: 0; }
        }
        #wheel-overlay, #game-over-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff; display: none; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; border-radius: 8px; text-align: center;
        }
        #wheel-spinner { font-size: 100px; margin-bottom: 20px; animation: spin 1.5s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #message-log {
            height: 250px; overflow-y: scroll; background: #343a40;
            border-radius: 0.25rem; border: 1px solid #495057; color: #f8f9fa;
        }
        #message-log p { margin: 0; padding: 2px 8px; }
        .player-box {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s ease-in-out;
            margin-bottom: 0.5rem;
        }
        .player-box.p1 { background-color: rgba(217, 4, 41, 0.1); }
        .player-box.p2 { background-color: rgba(0, 119, 182, 0.1); }
        .player-box.p3 { background-color: rgba(40, 167, 69, 0.1); }
        .player-box.p4 { background-color: rgba(255, 193, 7, 0.1); }
        .player-box.active-turn {
            border-color: var(--p1-color);
            box-shadow: 0 0 15px 3px var(--p1-color);
            transform: scale(1.03);
        }
        .player-box.active-turn.p1 { border-color: var(--p1-color); box-shadow: 0 0 15px 3px var(--p1-color); }
        .player-box.active-turn.p2 { border-color: var(--p2-color); box-shadow: 0 0 15px 3px var(--p2-color); }
        .player-box.active-turn.p3 { border-color: var(--p3-color); box-shadow: 0 0 15px 3px var(--p3-color); }
        .player-box.active-turn.p4 { border-color: var(--p4-color); box-shadow: 0 0 15px 3px var(--p4-color); }
    </style>
{% endblock %}


{% block content %}
    <h1 class="mb-4">Oyun Odası</h1>
    <div class="row">
        <div class="col-lg-7 col-md-8 mb-4">
            <div id="game-board-container">
                <div id="game-over-overlay">
                    <h2 class="mb-3">Oyun Bitti!</h2>
                    <h4 class="mb-4">Kazanan: <span id="winner-name">...</span></h4>
                    <a href="{% url 'game_specific_lobby' game_slug=game.game_type.slug %}" class="btn btn-primary btn-lg">Yeni Oyun</a>
                </div>
                <div id="wheel-overlay">
                    <div id="wheel-spinner"><i class="fas fa-compact-disc"></i></div>
                    <h4>Başlangıç sırası belirleniyor...</h4>
                    <h3 id="wheel-winner-name" class="mt-3" style="display: none;"></h3>
                </div>
                <div id="game-board">
                    </div>
            </div>
        </div>

        <div class="col-lg-5 col-md-4">
            <div class="card shadow-sm text-bg-dark border-secondary">
                <div class="card-header fs-5 border-secondary">
                    Oyun Bilgileri
                </div>
                <div class="card-body">
                    <h5 id="turn-indicator" class="card-title mb-3">
                        Sıra: {{ game.current_turn.username|default:"Oyuncular bekleniyor..." }}
                    </h5>

                    <div id="player-list-container">
                        {% for player in game.players.all %}
                            <div class="player-box p{{ forloop.counter }}" id="player-box-{{ player.username }}">
                                <strong>
                                    <i class="fas fa-circle" style="color: var(--p{{ forloop.counter }}-color);"></i>
                                    {{ player.username }}
                                </strong>
                                {% if player == game.host %}
                                    <span class="badge bg-warning float-end">Kurucu</span>
                                {% endif %}
                                {% if player == request.user %}
                                    <span class="badge bg-primary float-end me-1">Siz</span>
                                {% endif %}
                            </div>
                        {% endfor %}
                    </div>

                    {% if game.players.count < game.game_type.max_players and game.status == 'waiting' %}
                    <div class="alert alert-info mt-3" id="waiting-alert">
                        <i class="fas fa-spinner fa-spin me-1"></i>
                        Oyuncular bekleniyor... ({{ game.players.count }}/{{ game.game_type.max_players }})
                    </div>
                    {% endif %}

                    {% if is_spectator %}
                    {% endif %}

                    <hr class="border-secondary">
                    <label for="message-log" class="form-label">Oyun Kayıtları:</label>
                    <div id="message-log" class="p-2"></div>
                    <a href="{% url 'game_specific_lobby' game_slug=game.game_type.slug %}" class="btn btn-secondary mt-3 w-100">Lobiden Ayrıl</a>
                </div>
            </div>
        </div>
    </div>

    {{ game_id_json|json_script:"game-id" }}
    {{ username_json|json_script:"current-username" }}
    {{ is_spectator|json_script:"is-spectator" }}
    {{ initial_board_state_json|json_script:"initial-board-state" }}
    {{ board_size_json|json_script:"board-size-json" }}
{% endblock %}

{% block extra_js %}
    <script>
        // ... (Tüm değişken tanımlamaları aynı) ...
        const gameId = JSON.parse(document.getElementById('game-id').textContent);
        const myUsername = JSON.parse(document.getElementById('current-username').textContent);
        const isSpectator = JSON.parse(document.getElementById('is-spectator').textContent);
        const initialBoardState = JSON.parse(document.getElementById('initial-board-state').textContent);
        let boardSize = JSON.parse(document.getElementById('board-size-json').textContent);
        document.documentElement.style.setProperty('--board-size', boardSize);
        const boardElement = document.getElementById('game-board');
        const turnIndicator = document.getElementById('turn-indicator');
        const messageLog = document.getElementById('message-log');
        const playerListContainer = document.getElementById('player-list-container');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const winnerNameEl = document.getElementById('winner-name');
        const wheelOverlay = document.getElementById('wheel-overlay');
        const wheelWinnerText = document.getElementById('wheel-winner-name');
        let playerColors = {};
        let playerUsernames = [];
        const hostUsername = "{{ game.host.username }}";
        const diceIcons = { 1: 'fa-dice-one', 2: 'fa-dice-two', 3: 'fa-dice-three' };
        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const gameSocket = new WebSocket(
            wsProtocol + window.location.host + '/ws/dice-wars/' + gameId + '/'
        );

        // ... (gameSocket.onmessage fonksiyonu aynı) ...
        gameSocket.onmessage = async function(e) {
            const data = JSON.parse(e.data);
            console.log("Sunucudan alındı:", data);

            if (data.type === 'error') {
                logMessage(data.message, 'danger');
                return;
            }

            // 'game_message' consumer'da 'game_state' olarak güncellendi
            if (data.type === 'game_state') {

                // 1. Oyuncu Bilgilerini Güncelle
                if (data.players) {
                    playerUsernames = data.players;
                    updatePlayerList(data.players);
                }
                if (data.board_size && data.board_size !== boardSize) {
                    console.log(`Tahta boyutu ${boardSize}'dan ${data.board_size}'a güncellendi.`);
                    boardSize = data.board_size;
                    document.documentElement.style.setProperty('--board-size', boardSize);
                }

                // 2. Sıra Göstergesini Güncelle
                updateTurnIndicator(data.turn, data.status, data.winner);

                // 3. Başlangıç Çarkı
                if (data.special_event === 'game_start_roll') {
                    wheelWinnerText.style.display = 'none';
                    wheelOverlay.classList.remove('finished');
                    wheelOverlay.style.display = 'flex';
                    await sleep(2500);
                    wheelWinnerText.innerHTML = `<i class="fas fa-check-circle"></i> ${data.turn} başlıyor!`;
                    wheelWinnerText.style.display = 'block';
                    wheelOverlay.classList.add('finished');
                    await sleep(2000);
                    wheelOverlay.style.display = 'none';
                    logMessage(data.message, 'success');
                }

                // 4. Sıralı Patlama Animasyonu
                if (data.exploded_cells && data.exploded_cells.length > 0) {
                    data.exploded_cells.forEach(([r, c]) => {
                        const cellEl = boardElement.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                        if (cellEl) {
                            cellEl.innerHTML = '';
                            cellEl.className = 'cell';
                        }
                    });
                    await sleep(50);
                }

                renderBoard(data.state);

                if (data.exploded_cells && data.exploded_cells.length > 0) {
                    triggerSequentialExplosions(data.exploded_cells);
                }

                if (data.message && data.special_event !== 'game_start_roll') {
                    logMessage(data.message, 'info');
                }
            }
        };

        // ... (onclose ve onopen aynı) ...
        gameSocket.onclose = function(e) {
            console.error('WebSocket bağlantısı kapandı.');
            logMessage('Sunucuyla bağlantı koptu. Sayfayı yenileyin.', 'danger');
            turnIndicator.textContent = "Bağlantı Kesildi";
        };

        gameSocket.onopen = function(e) {
            logMessage('Oyun masasına başarıyla bağlandınız.', 'success');
            updatePlayerList([{% for p in game.players.all %}"{{ p.username }}"{% if not forloop.last %}, {% endif %}{% endfor %}]);
        };

        // ... (updatePlayerList aynı) ...
        function updatePlayerList(players) {
            playerListContainer.innerHTML = '';
            playerColors = {};

            players.forEach((username, index) => {
                const playerClass = `p${index + 1}`;
                playerColors[username] = playerClass;

                const playerBox = document.createElement('div');
                playerBox.className = `player-box ${playerClass}`;
                playerBox.id = `player-box-${username}`;

                let badges = '';
                if (username === hostUsername) {
                    badges += `<span class="badge bg-warning float-end">Kurucu</span>`;
                }
                if (username === myUsername) {
                    badges += `<span class="badge bg-primary float-end me-1">Siz</span>`;
                }

                playerBox.innerHTML = `
                    <strong>
                        <i class="fas fa-circle" style="color: var(--${playerClass}-color);"></i>
                        ${username}
                    </strong>
                    ${badges}
                `;
                playerListContainer.appendChild(playerBox);
            });
        }

        // --- DEĞİŞEN FONKSİYON ---
        function updateTurnIndicator(turnUsername, status, winnerUsername) {
            // "Oyuncular bekleniyor" alert'ini bul
            const waitingAlert = document.getElementById('waiting-alert');

            document.querySelectorAll('.player-box').forEach(box => {
                box.classList.remove('active-turn');
            });

            if (status === 'finished') {
                turnIndicator.textContent = "Oyun Bitti!";
                logMessage("Kazanan: " + winnerUsername, 'success');
                winnerNameEl.textContent = winnerUsername;
                gameOverOverlay.style.display = 'flex';

                // Alert'i gizle
                if (waitingAlert) waitingAlert.style.display = 'none';

            } else if (status === 'waiting') {
                turnIndicator.textContent = "Oyuncular bekleniyor...";

                // Alert'i göster (gerçi zaten görünür olmalı)
                if (waitingAlert) waitingAlert.style.display = 'block';

            } else if (status === 'in_progress' && turnUsername) {
                turnIndicator.textContent = "Sıra: " + turnUsername;

                // Alert'i gizle
                if (waitingAlert) waitingAlert.style.display = 'none';

                const activePlayerBox = document.getElementById(`player-box-${turnUsername}`);
                if (activePlayerBox) {
                    activePlayerBox.classList.add('active-turn');
                }
            }
        }

        // ... (triggerSequentialExplosions aynı) ...
        async function triggerSequentialExplosions(explodedCells) {
            const EXPLOSION_DELAY = 200;
            for (const coords of explodedCells) {
                const [r, c] = coords;
                const cellEl = boardElement.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                if (cellEl) {
                    const playerClass = Array.from(cellEl.classList).find(c => c.startsWith('p'));
                    const color = playerClass ? `var(--${playerClass}-color)` : 'var(--cell-border)';

                    createExplosion(cellEl, color);
                    await sleep(EXPLOSION_DELAY);
                }
            }
            await sleep(400);
        }

        // ... (renderBoard aynı, dinamik boardSize'ı zaten kullanıyor) ...
        function renderBoard(boardState) {
            boardElement.innerHTML = '';
            for (let r = 0; r < boardSize; r++) {
                for (let c = 0; c < boardSize; c++) {
                    const cellElement = document.createElement('div');
                    cellElement.classList.add('cell');
                    cellElement.dataset.row = r;
                    cellElement.dataset.col = c;
                    const rowData = boardState[String(r)];
                    const cellData = rowData ? rowData[String(c)] : null;
                    if (cellData && cellData.count > 0) {
                        if (diceIcons[cellData.count]) {
                            const icon = document.createElement('i');
                            icon.className = `fas ${diceIcons[cellData.count]}`;
                            cellElement.appendChild(icon);
                        } else {
                            cellElement.textContent = cellData.count;
                        }
                        const playerClass = playerColors[cellData.owner];
                        if (playerClass) {
                            cellElement.classList.add(playerClass);
                        }
                    } else {
                        cellElement.innerHTML = '';
                    }
                    boardElement.appendChild(cellElement);
                }
            }
        }

        // ... (click listener, logMessage, createExplosion fonksiyonları aynı) ...
        boardElement.addEventListener('click', function(e) {
            const cell = e.target.closest('.cell');
            if (!cell) return;
            if (isSpectator) {
                logMessage("İzleyiciler hamle yapamaz.", 'warning');
                return;
            }
            if (gameOverOverlay.style.display === 'flex' || wheelOverlay.style.display === 'flex') {
                return;
            }
            const row = cell.dataset.row;
            const col = cell.dataset.col;
            gameSocket.send(JSON.stringify({
                'type': 'make_move',
                'row': parseInt(row),
                'col': parseInt(col)
            }));
        });
        function logMessage(msg, type = 'info') {
            let textClass = 'text-info';
            if (type === 'danger') { textClass = 'text-danger'; }
            else if (type === 'success') { textClass = 'text-success'; }
            else if (type === 'warning') { textClass = 'text-warning'; }
            const p = document.createElement('p');
            p.classList.add('m-0', 'small', textClass);
            p.textContent = msg;
            messageLog.appendChild(p);
            messageLog.scrollTop = messageLog.scrollHeight;
        }
        function createExplosion(cellEl, color) {
            const gameBoardContainer = document.getElementById('game-board-container');
            const rect = cellEl.getBoundingClientRect();
            const containerRect = gameBoardContainer.getBoundingClientRect();
            const startTop = rect.top - containerRect.top + (rect.height / 2);
            const startLeft = rect.left - containerRect.left + (rect.width / 2);
            const directions = ['up', 'down', 'left', 'right'];
            cellEl.style.setProperty('color', color);
            cellEl.classList.add('explode-flash');
            setTimeout(() => {
                cellEl.classList.remove('explode-flash');
                cellEl.style.removeProperty('color');
            }, 400);
            for (const dir of directions) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                const icon = document.createElement('i');
                icon.className = `fas fa-dice-one`;
                particle.appendChild(icon);
                particle.style.color = color;
                particle.style.top = `${startTop}px`;
                particle.style.left = `${startLeft}px`;
                gameBoardContainer.appendChild(particle);
                void particle.offsetWidth;
                particle.classList.add(dir);
                setTimeout(() => {
                    if (particle.parentElement) {
                        particle.parentElement.removeChild(particle);
                    }
                }, 600);
            }
        }

        // ... (İlk renderBoard çağrısı aynı) ...
        console.log(`İlk tahta ${boardSize}x${boardSize} olarak çiziliyor...`, initialBoardState);
        renderBoard(initialBoardState);

    </script>
{% endblock %}